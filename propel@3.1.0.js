require=function(r,e,n){function t(n,o){function i(r){return t(i.resolve(r))}function f(e){return r[n][1][e]||e}if(!e[n]){if(!r[n]){var c="function"==typeof require&&require;if(!o&&c)return c(n,!0);if(u)return u(n,!0);var l=new Error("Cannot find module '"+n+"'");throw l.code="MODULE_NOT_FOUND",l}i.resolve=f;var a=e[n]=new t.Module;r[n][0].call(a.exports,i,a,a.exports)}return e[n].exports}function o(){this.bundle=t,this.exports={}}var u="function"==typeof require&&require;t.Module=o,t.modules=r,t.cache=e,t.parent=u;for(var i=0;i<n.length;i++)t(n[i]);return t}({528:[function(require,module,exports) {
!function(n,t,e){function s(n,t){return t.c=n.c,t.s0=n.s0,t.s1=n.s1,t.s2=n.s2,t}function r(n,t){var e=new function(n){var t=this,e=function(){var n=4022871197;return function(t){t=t.toString();for(var e=0;e<t.length;e++){var s=.02519603282416938*(n+=t.charCodeAt(e));s-=n=s>>>0,n=(s*=n)>>>0,n+=4294967296*(s-=n)}return 2.3283064365386963e-10*(n>>>0)}}();t.next=function(){var n=2091639*t.s0+2.3283064365386963e-10*t.c;return t.s0=t.s1,t.s1=t.s2,t.s2=n-(t.c=0|n)},t.c=1,t.s0=e(" "),t.s1=e(" "),t.s2=e(" "),t.s0-=e(n),t.s0<0&&(t.s0+=1),t.s1-=e(n),t.s1<0&&(t.s1+=1),t.s2-=e(n),t.s2<0&&(t.s2+=1),e=null}(n),r=t&&t.state,u=e.next;return u.int32=function(){return 4294967296*e.next()|0},u.double=function(){return u()+1.1102230246251565e-16*(2097152*u()|0)},u.quick=u,r&&("object"==typeof r&&s(r,e),u.state=function(){return s(e,{})}),u}t&&t.exports?t.exports=r:e&&e.amd?e(function(){return r}):this.alea=r}(0,"object"==typeof module&&module,"function"==typeof define&&define); 
},{}],527:[function(require,module,exports) {
!function(t,n,e){function o(t,n){return n.x=t.x,n.y=t.y,n.z=t.z,n.w=t.w,n}function r(t,n){var e=new function(t){var n=this,e="";n.x=0,n.y=0,n.z=0,n.w=0,n.next=function(){var t=n.x^n.x<<11;return n.x=n.y,n.y=n.z,n.z=n.w,n.w^=n.w>>>19^t^t>>>8},t===(0|t)?n.x=t:e+=t;for(var o=0;o<e.length+64;o++)n.x^=0|e.charCodeAt(o),n.next()}(t),r=n&&n.state,u=function(){return(e.next()>>>0)/4294967296};return u.double=function(){do{var t=((e.next()>>>11)+(e.next()>>>0)/4294967296)/(1<<21)}while(0===t);return t},u.int32=e.next,u.quick=u,r&&("object"==typeof r&&o(r,e),u.state=function(){return o(e,{})}),u}n&&n.exports?n.exports=r:e&&e.amd?e(function(){return r}):this.xor128=r}(0,"object"==typeof module&&module,"function"==typeof define&&define);
},{}],526:[function(require,module,exports) {
!function(t,n,e){function o(t,n){return n.x=t.x,n.y=t.y,n.z=t.z,n.w=t.w,n.v=t.v,n.d=t.d,n}function r(t,n){var e=new function(t){var n=this,e="";n.next=function(){var t=n.x^n.x>>>2;return n.x=n.y,n.y=n.z,n.z=n.w,n.w=n.v,(n.d=n.d+362437|0)+(n.v=n.v^n.v<<4^t^t<<1)|0},n.x=0,n.y=0,n.z=0,n.w=0,n.v=0,t===(0|t)?n.x=t:e+=t;for(var o=0;o<e.length+64;o++)n.x^=0|e.charCodeAt(o),o==e.length&&(n.d=n.x<<10^n.x>>>4),n.next()}(t),r=n&&n.state,u=function(){return(e.next()>>>0)/4294967296};return u.double=function(){do{var t=((e.next()>>>11)+(e.next()>>>0)/4294967296)/(1<<21)}while(0===t);return t},u.int32=e.next,u.quick=u,r&&("object"==typeof r&&o(r,e),u.state=function(){return o(e,{})}),u}n&&n.exports?n.exports=r:e&&e.amd?e(function(){return r}):this.xorwow=r}(0,"object"==typeof module&&module,"function"==typeof define&&define);
},{}],525:[function(require,module,exports) {
!function(n,t,e){function r(n,t){return t.x=n.x.slice(),t.i=n.i,t}function i(n,t){null==n&&(n=+new Date);var e=new function(n){var t=this;t.next=function(){var n,e,r=t.x,i=t.i;return n=r[i],n^=n>>>7,e=n^n<<24,n=r[i+1&7],e^=n^n>>>10,n=r[i+3&7],e^=n^n>>>3,n=r[i+4&7],e^=n^n<<7,n=r[i+7&7],n^=n<<13,e^=n^n<<9,r[i]=e,t.i=i+1&7,e},function(n,t){var e,r=[];if(t===(0|t))r[0]=t;else for(t=""+t,e=0;e<t.length;++e)r[7&e]=r[7&e]<<15^t.charCodeAt(e)+r[e+1&7]<<13;for(;r.length<8;)r.push(0);for(e=0;e<8&&0===r[e];++e);for(8==e?r[7]=-1:r[e],n.x=r,n.i=0,e=256;e>0;--e)n.next()}(t,n)}(n),i=t&&t.state,o=function(){return(e.next()>>>0)/4294967296};return o.double=function(){do{var n=((e.next()>>>11)+(e.next()>>>0)/4294967296)/(1<<21)}while(0===n);return n},o.int32=e.next,o.quick=o,i&&(i.x&&r(i,e),o.state=function(){return r(e,{})}),o}t&&t.exports?t.exports=i:e&&e.amd?e(function(){return i}):this.xorshift7=i}(0,"object"==typeof module&&module,"function"==typeof define&&define);
},{}],530:[function(require,module,exports) {
!function(n,t,e){function r(n,t){return t.i=n.i,t.w=n.w,t.X=n.X.slice(),t}function i(n,t){null==n&&(n=+new Date);var e=new function(n){var t=this;t.next=function(){var n,e,r=t.w,i=t.X,o=t.i;return t.w=r=r+1640531527|0,e=i[o+34&127],n=i[o=o+1&127],e^=e<<13,n^=n<<17,e^=e>>>15,n^=n>>>12,e=i[o]=e^n,t.i=o,e+(r^r>>>16)|0},function(n,t){var e,r,i,o,u,f=[],c=128;for(t===(0|t)?(r=t,t=null):(t+="\0",r=0,c=Math.max(c,t.length)),i=0,o=-32;o<c;++o)t&&(r^=t.charCodeAt((o+32)%t.length)),0===o&&(u=r),r^=r<<10,r^=r>>>15,r^=r<<4,r^=r>>>13,o>=0&&(u=u+1640531527|0,i=0==(e=f[127&o]^=r+u)?i+1:0);for(i>=128&&(f[127&(t&&t.length||0)]=-1),i=127,o=512;o>0;--o)r=f[i+34&127],e=f[i=i+1&127],r^=r<<13,e^=e<<17,r^=r>>>15,e^=e>>>12,f[i]=r^e;n.w=u,n.X=f,n.i=i}(t,n)}(n),i=t&&t.state,o=function(){return(e.next()>>>0)/4294967296};return o.double=function(){do{var n=((e.next()>>>11)+(e.next()>>>0)/4294967296)/(1<<21)}while(0===n);return n},o.int32=e.next,o.quick=o,i&&(i.X&&r(i,e),o.state=function(){return r(e,{})}),o}t&&t.exports?t.exports=i:e&&e.amd?e(function(){return i}):this.xor4096=i}(0,"object"==typeof module&&module,"function"==typeof define&&define);
},{}],529:[function(require,module,exports) {
!function(t,n,e){function o(t,n){return n.a=t.a,n.b=t.b,n.c=t.c,n.d=t.d,n}function r(t,n){var e=new function(t){var n=this,e="";n.next=function(){var t=n.b,e=n.c,o=n.d,r=n.a;return t=t<<25^t>>>7^e,e=e-o|0,o=o<<24^o>>>8^r,r=r-t|0,n.b=t=t<<20^t>>>12^e,n.c=e=e-o|0,n.d=o<<16^e>>>16^r,n.a=r-t|0},n.a=0,n.b=0,n.c=-1640531527,n.d=1367130551,t===Math.floor(t)?(n.a=t/4294967296|0,n.b=0|t):e+=t;for(var o=0;o<e.length+20;o++)n.b^=0|e.charCodeAt(o),n.next()}(t),r=n&&n.state,u=function(){return(e.next()>>>0)/4294967296};return u.double=function(){do{var t=((e.next()>>>11)+(e.next()>>>0)/4294967296)/(1<<21)}while(0===t);return t},u.int32=e.next,u.quick=u,r&&("object"==typeof r&&o(r,e),u.state=function(){return o(e,{})}),u}n&&n.exports?n.exports=r:e&&e.amd?e(function(){return r}):this.tychei=r}(0,"object"==typeof module&&module,"function"==typeof define&&define);
},{}],531:[function(require,module,exports) {

},{}],524:[function(require,module,exports) {
var global = (1,eval)("this");
var n=(0,eval)("this");!function(n,r){function t(t,y,v){var m=[],j=i(o((y=1==y?{entropy:!0}:y||{}).entropy?[t,u(n)]:null==t?function(){try{var r;return a&&(r=a.randomBytes)?r=r(c):(r=new Uint8Array(c),(f.crypto||f.msCrypto).getRandomValues(r)),u(r)}catch(r){var t=f.navigator,e=t&&t.plugins;return[+new Date,f,e,f.screen,u(n)]}}():t,3),m),S=new function(n){var r,t=n.length,e=this,o=0,i=e.i=e.j=0,u=e.S=[];t||(n=[t++]);for(;o<c;)u[o]=o++;for(o=0;o<c;o++)u[o]=u[i=h&i+n[o%t]+(r=u[o])],u[i]=r;(e.g=function(n){for(var r,t=0,o=e.i,i=e.j,u=e.S;n--;)r=u[o=h&o+1],t=t*c+u[h&(u[o]=u[i=h&i+r])+(u[i]=r)];return e.i=o,e.j=i,t})(c)}(m),b=function(){for(var n=S.g(s),r=p,t=0;n<d;)n=(n+t)*c,r*=c,t=S.g(1);for(;n>=g;)n/=2,r/=2,t>>>=1;return(n+t)/r};return b.int32=function(){return 0|S.g(4)},b.quick=function(){return S.g(4)/4294967296},b.double=b,i(u(S.S),n),(y.pass||v||function(n,t,o,i){return i&&(i.S&&e(i,S),n.state=function(){return e(S,{})}),o?(r[l]=n,t):n})(b,j,"global"in y?y.global:this==r,y.state)}function e(n,r){return r.i=n.i,r.j=n.j,r.S=n.S.slice(),r}function o(n,r){var t,e=[],i=typeof n;if(r&&"object"==i)for(t in n)try{e.push(o(n[t],r-1))}catch(n){}return e.length?e:"string"==i?n:n+"\0"}function i(n,r){for(var t,e=n+"",o=0;o<e.length;)r[h&o]=h&(t^=19*r[h&o])+e.charCodeAt(o++);return u(r)}function u(n){return String.fromCharCode.apply(0,n)}var a,f=this,c=256,s=6,l="random",p=r.pow(c,s),d=r.pow(2,52),g=2*d,h=c-1;if(r["seed"+l]=t,i(r.random(),n),"object"==typeof module&&module.exports){module.exports=t;try{a=require("crypto")}catch(n){}}else"function"==typeof define&&define.amd&&define(function(){return t})}([],Math);
},{"crypto":531}],523:[function(require,module,exports) {
var r=require("./lib/alea"),e=require("./lib/xor128"),i=require("./lib/xorwow"),o=require("./lib/xorshift7"),l=require("./lib/xor4096"),x=require("./lib/tychei"),u=require("./seedrandom");u.alea=r,u.xor128=e,u.xorwow=i,u.xorshift7=o,u.xor4096=l,u.tychei=x,module.exports=u;
},{"./lib/alea":528,"./lib/xor128":527,"./lib/xorwow":526,"./lib/xorshift7":525,"./lib/xor4096":530,"./lib/tychei":529,"./seedrandom":524}],26:[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0});const t=require("seedrandom");class e{constructor(e,s,i,a,n){this.mean=e,this.stdDev=s,this.dtype=i,this.nextVal=NaN,this.truncated=a,this.truncated&&(this.upper=this.mean+2*this.stdDev,this.lower=this.mean-2*this.stdDev);const r=n||Math.random();this.random=t.alea(r.toString())}nextValue(){if(!isNaN(this.nextVal)){const t=this.nextVal;return this.nextVal=NaN,t}let t,e,s=!1;for(;!s;){let i,a,n;do{n=(i=2*this.random()-1)*i+(a=2*this.random()-1)*a}while(n>=1||0===n);const r=Math.sqrt(-2*Math.log(n)/n);t=this.mean+this.stdDev*i*r,e=this.mean+this.stdDev*a*r,this.truncated&&!this.isValidTruncated(t)||(s=!0)}return this.truncated&&!this.isValidTruncated(e)||(this.nextVal=this.convertValue(e)),this.convertValue(t)}convertValue(t){return null==this.dtype||"float32"===this.dtype?t:Math.round(t)}isValidTruncated(t){return t<=this.upper&&t>=this.lower}}exports.MPRandGauss=e;
},{"seedrandom":523}],17:[function(require,module,exports) {
"use strict";function t(t,e){if(null==e||"float32"===e)return new Float32Array(t);if("int32"===e){const e=new Int32Array(t.length);for(let r=0;r<e.length;++r){const s=t[r];o.isValNaN(s,"int32")?e[r]=o.getNaN("int32"):e[r]=s}return e}if("bool"===e){const e=new Uint8Array(t.length);for(let r=0;r<e.length;++r){const s=t[r];o.isValNaN(s,"bool")?e[r]=o.getNaN("bool"):0!==Math.round(s)&&(e[r]=1)}return e}throw new Error(`Unknown data type ${e}`)}function e(t){return t instanceof Float32Array||t instanceof Int32Array||t instanceof Uint8Array}function r(t,e){return t instanceof Float32Array&&"float32"===e||t instanceof Int32Array&&"int32"===e||t instanceof Uint8Array&&"bool"===e}function s(e,s){return r(e,s)?e:(Array.isArray(e)&&(e=o.flatten(e)),t(e,s))}function a(t,e){if(null==e||"float32"===e)return new Float32Array(t);if("int32"===e)return new Int32Array(t);if("bool"===e)return new Uint8Array(t);throw new Error(`Unknown data type ${e}`)}function n(t,e){const r=a(t,e);for(let t=0;t<r.length;t++)r[t]=1;return r}Object.defineProperty(exports,"__esModule",{value:!0});const i=require("../environment"),o=require("../util"),h=require("./rand");var d;!function(t){t.float32="float32",t.int32="int32",t.bool="bool"}(d=exports.DType||(exports.DType={}));class u{}exports.DataId=u;class l{constructor(t,e,r,s,a){this.isDisposed=!1,this.math=a||i.ENV.math,this.size=o.sizeFromShape(t),null!=r&&o.assert(this.size===r.length,`Constructing ndarray of shape (${this.size}) should match the `+`length of values (${r.length})`),this.shape=t,this.dtype=e||"float32";const n=this.shape.length;if(n<2)this.strides=[];else{this.strides=new Array(n-1),this.strides[n-2]=this.shape[n-1];for(let t=n-3;t>=0;--t)this.strides[t]=this.strides[t+1]*this.shape[t+1]}this.dataId=null!=s?s:new u,this.id=l.nextId++,this.rankType=this.rank<5?this.rank.toString():"higher",this.math.register(this),null!=r&&this.math.write(this.dataId,r)}static ones(t,e){const r=n(o.sizeFromShape(t),e);return l.make(t,{values:r},e)}static zeros(t,e){const r=a(o.sizeFromShape(t),e);return l.make(t,{values:r},e)}static onesLike(t){return l.ones(t.shape,t.dtype)}static zerosLike(t){return l.zeros(t.shape,t.dtype)}static like(e){const r=t(e.dataSync(),e.dtype);return l.make(e.shape,{values:r},e.dtype,e.math)}static make(t,e,r,s){switch(t.length){case 0:return new c(t,r,e.values,e.dataId,s);case 1:return new p(t,r,e.values,e.dataId,s);case 2:return new f(t,r,e.values,e.dataId,s);case 3:return new w(t,r,e.values,e.dataId,s);case 4:return new y(t,r,e.values,e.dataId,s);default:return new l(t,r,e.values,e.dataId,s)}}static fromPixels(t,e=3,r){if(e>4)throw new Error("Cannot construct NDArray with more than 4 channels from pixels.");const s=[t.height,t.width,e];r=r||i.ENV.math;const a=l.make(s,{},"int32",r);return r.writePixels(a.dataId,t,e),a}reshape(t){return this.throwIfDisposed(),this.math.reshape(this,t)}flatten(){return this.throwIfDisposed(),this instanceof p?this:this.as1D()}asScalar(){return this.throwIfDisposed(),o.assert(1===this.size,"The array must have only 1 element."),this.reshape([])}as1D(){return this.throwIfDisposed(),this.reshape([this.size])}as2D(t,e){return this.throwIfDisposed(),this.reshape([t,e])}as3D(t,e,r){return this.throwIfDisposed(),this.reshape([t,e,r])}as4D(t,e,r,s){return this.throwIfDisposed(),this.reshape([t,e,r,s])}asType(t){return this.throwIfDisposed(),this.math.cast(this,t)}get rank(){return this.shape.length}get(...t){let e=t[t.length-1];for(let r=0;r<t.length-1;++r)e+=this.strides[r]*t[r];return this.dataSync()[e]}add(t,...e){this.set(this.get(...e)+t,...e)}set(t,...e){this.throwIfDisposed(),o.assert(e.length===this.rank,`The number of provided coordinates (${e.length}) must `+`match the rank (${this.rank})`);let r=e.length>0?e[e.length-1]:0;for(let t=0;t<e.length-1;++t)r+=this.strides[t]*e[t];const s=this.dataSync();s[r]=t,this.math.write(this.dataId,s)}async val(...t){return this.throwIfDisposed(),await this.data(),this.get(...t)}locToIndex(t){this.throwIfDisposed();let e=t[t.length-1];for(let r=0;r<t.length-1;++r)e+=this.strides[r]*t[r];return e}indexToLoc(t){this.throwIfDisposed();const e=new Array(this.shape.length);for(let r=0;r<e.length-1;++r)e[r]=Math.floor(t/this.strides[r]),t-=e[r]*this.strides[r];return e[e.length-1]=t,e}fill(t){this.throwIfDisposed();const e=this.dataSync();e.fill(t),this.math.write(this.dataId,e)}getValues(){return this.dataSync()}getValuesAsync(){return this.data()}async data(){return this.throwIfDisposed(),this.math.read(this.dataId)}dataSync(){return this.throwIfDisposed(),this.math.readSync(this.dataId)}dispose(){this.isDisposed||(this.isDisposed=!0,this.math.disposeData(this.dataId))}equals(t){return this.throwIfDisposed(),this.dtype===t.dtype&&o.arraysEqual(this.shape,t.shape)&&o.arraysEqual(this.dataSync(),t.dataSync())}static rand(t,e,r){const s=o.sizeFromShape(t);let a=null;if(null==r||"float32"===r)a=new Float32Array(s);else if("int32"===r)a=new Int32Array(s);else{if("bool"!==r)throw new Error(`Unknown data type ${r}`);a=new Uint8Array(s)}for(let t=0;t<s;t++)a[t]=e();return l.make(t,{values:a},r)}static randNormal(t,e=0,r=1,s,a){if(null!=s&&"bool"===s)throw new Error(`Unsupported data type ${s}`);const n=new h.MPRandGauss(e,r,s,!1,a);return l.rand(t,()=>n.nextValue(),s)}static randTruncatedNormal(t,e=0,r=1,s,a){if(null!=s&&"bool"===s)throw new Error(`Unsupported data type ${s}`);const n=new h.MPRandGauss(e,r,s,!0,a);return l.rand(t,()=>n.nextValue(),s)}static randUniform(t,e,r,s){return l.rand(t,()=>o.randUniform(e,r),s)}throwIfDisposed(){if(this.isDisposed)throw new Error("NDArray is disposed.")}}l.nextId=0,exports.NDArray=l;class c extends l{static new(t,e){return new c([],e,s([t],e))}get(){return this.dataSync()[0]}async val(){return await this.data(),this.get()}add(t){this.dataSync()[0]+=t}asType(t){return super.asType(t)}locToIndex(t){return 0}indexToLoc(t){return[]}}exports.Scalar=c;class p extends l{static new(t,r){if(!e(t)){const e=o.inferShape(t);o.assert(1===e.length,`Error constructing Array1D. Shape of values ${e} is `+"not 1 dimensional.")}return new p([t.length],r,s(t,r))}get(t){return this.dataSync()[t]}async val(t){return await this.data(),this.get(t)}add(t,e){this.dataSync()[e]+=t}locToIndex(t){return t[0]}indexToLoc(t){return[t]}asType(t){return super.asType(t)}static ones(t,e){return l.ones(t,e)}static zeros(t,e){return l.zeros(t,e)}static randNormal(t,e=0,r=1,s,a){if(null!=s&&"bool"===s)throw new Error(`Unsupported data type ${s}`);const n=new h.MPRandGauss(e,r,s,!1,a);return l.rand(t,()=>n.nextValue(),s)}static randTruncatedNormal(t,e=0,r=1,s,a){if(null!=s&&"bool"===s)throw new Error(`Unsupported data type ${s}`);const n=new h.MPRandGauss(e,r,s,!0,a);return l.rand(t,()=>n.nextValue(),s)}static randUniform(t,e,r,s){return l.rand(t,()=>o.randUniform(e,r),s)}}exports.Array1D=p;class f extends l{constructor(t,e,r,s,a){o.assert(2===t.length,"Shape should be of length 2"),super(t,e,r,s,a)}static new(t,r,a){if(!e(r)){const e=o.inferShape(r);e.length>1&&o.assertShapesMatch(t,e,"Error when constructing Array2D. Shape of values "+`${e} does not match the provided shape `+`${t}. `)}return new f(t,a,s(r,a))}get(t,e){return this.dataSync()[this.strides[0]*t+e]}add(t,e,r){this.dataSync()[this.strides[0]*e+r]+=t}async val(t,e){return await this.data(),this.get(t,e)}locToIndex(t){return this.strides[0]*t[0]+t[1]}indexToLoc(t){return[Math.floor(t/this.strides[0]),t%this.strides[0]]}asType(t){return super.asType(t)}static ones(t,e){return l.ones(t,e)}static zeros(t,e){return l.zeros(t,e)}static randNormal(t,e=0,r=1,s,a){if(null!=s&&"bool"===s)throw new Error(`Unsupported data type ${s}`);const n=new h.MPRandGauss(e,r,s,!1,a);return l.rand(t,()=>n.nextValue(),s)}static randTruncatedNormal(t,e=0,r=1,s,a){if(null!=s&&"bool"===s)throw new Error(`Unsupported data type ${s}`);const n=new h.MPRandGauss(e,r,s,!0,a);return l.rand(t,()=>n.nextValue(),s)}static randUniform(t,e,r,s){return l.rand(t,()=>o.randUniform(e,r),s)}}exports.Array2D=f;class w extends l{constructor(t,e,r,s,a){o.assert(3===t.length,"Shape should be of length 3"),super(t,e,r,s,a)}static new(t,r,a){if(!e(r)){const e=o.inferShape(r);e.length>1&&o.assertShapesMatch(t,e,"Error when constructing Array3D. Shape of values "+`${e} does not match the provided shape `+`${t}. `)}return new w(t,a,s(r,a))}get(t,e,r){return this.dataSync()[this.strides[0]*t+this.strides[1]*e+r]}async val(t,e,r){return await this.data(),this.get(t,e,r)}add(t,e,r,s){this.dataSync()[this.strides[0]*e+this.strides[1]*r+s]+=t}locToIndex(t){return this.strides[0]*t[0]+this.strides[1]*t[1]+t[2]}indexToLoc(t){const e=Math.floor(t/this.strides[0]);return t-=e*this.strides[0],[e,Math.floor(t/this.strides[1]),t%this.strides[1]]}static ones(t,e){return l.ones(t,e)}asType(t){return super.asType(t)}static zeros(t,e){return l.zeros(t,e)}static randNormal(t,e=0,r=1,s,a){if(null!=s&&"bool"===s)throw new Error(`Unsupported data type ${s}`);const n=new h.MPRandGauss(e,r,s,!1,a);return l.rand(t,()=>n.nextValue(),s)}static randTruncatedNormal(t,e=0,r=1,s,a){if(null!=s&&"bool"===s)throw new Error(`Unsupported data type ${s}`);const n=new h.MPRandGauss(e,r,s,!0,a);return l.rand(t,()=>n.nextValue(),s)}static randUniform(t,e,r,s){return l.rand(t,()=>o.randUniform(e,r),s)}}exports.Array3D=w;class y extends l{constructor(t,e,r,s,a){o.assert(4===t.length,"Shape should be of length 4"),super(t,e,r,s,a)}static new(t,r,a){if(!e(r)){const e=o.inferShape(r);e.length>1&&o.assertShapesMatch(t,e,"Error when constructing Array4D. Shape of values "+`${e} does not match the provided shape `+`${t}. `)}return new y(t,a,s(r,a))}get(t,e,r,s){return this.dataSync()[this.strides[0]*t+this.strides[1]*e+this.strides[2]*r+s]}async val(t,e,r,s){return await this.data(),this.get(t,e,r,s)}add(t,e,r,s,a){this.dataSync()[this.strides[0]*e+this.strides[1]*r+this.strides[2]*s+a]+=t}locToIndex(t){return this.strides[0]*t[0]+this.strides[1]*t[1]+this.strides[2]*t[2]+t[3]}indexToLoc(t){const e=Math.floor(t/this.strides[0]);t-=e*this.strides[0];const r=Math.floor(t/this.strides[1]);return t-=r*this.strides[1],[e,r,Math.floor(t/this.strides[2]),t%this.strides[2]]}asType(t){return super.asType(t)}static ones(t,e){return l.ones(t,e)}static zeros(t,e){return l.zeros(t,e)}static randNormal(t,e=0,r=1,s,a){if(null!=s&&"bool"===s)throw new Error(`Unsupported data type ${s}`);const n=new h.MPRandGauss(e,r,s,!1,a);return l.rand(t,()=>n.nextValue(),s)}static randTruncatedNormal(t,e=0,r=1,s,a){if(null!=s&&"bool"===s)throw new Error(`Unsupported data type ${s}`);const n=new h.MPRandGauss(e,r,s,!0,a);return l.rand(t,()=>n.nextValue(),s)}static randUniform(t,e,r,s){return l.rand(t,()=>o.randUniform(e,r),s)}}exports.Array4D=y;
},{"../environment":15,"../util":24,"./rand":26}],24:[function(require,module,exports) {
"use strict";function t(t){let e=t.length,r=0,n=0;for(;e>0;)n=Math.random()*e|0,r=t[--e],t[e]=t[n],t[n]=r}function e(t,e,r){return Math.max(t,Math.min(e,r))}function r(t,e){return Math.random()*(e-t)+t}function n(t,e){let r=0;for(let n=0;n<t.length;n++){const o=Number(t[n])-Number(e[n]);r+=o*o}return r}function o(t,e){if(!t)throw new Error(e)}function s(t,e,r=""){o(p(t,e),r+`Shapes ${t} and ${e} must match`)}function a(t,e){o(t.dtype===e.dtype,`The dtypes of the first (${t.dtype}) and `+`second (${e.dtype}) input must match`)}function i(t,e=[]){if(Array.isArray(t))for(let r=0;r<t.length;++r)i(t[r],e);else e.push(t);return e}function u(t){const e=[];for(;t instanceof Array;)e.push(t.length),t=t[0];return e}function f(t){if(0===t.length)return 1;let e=t[0];for(let r=1;r<t.length;r++)e*=t[r];return e}function l(t){return 0===t.length}function p(t,e){if(t.length!==e.length)return!1;for(let r=0;r<t.length;r++)if(t[r]!==e[r])return!1;return!0}function h(t){return t%1==0}function c(t){if(null!=Math.tanh)return Math.tanh(t);if(t===1/0)return 1;if(t===-1/0)return-1;{const e=Math.exp(2*t);return(e-1)/(e+1)}}function d(t){for(let e=Math.floor(Math.sqrt(t));e>1;--e)if(t%e==0)return[e,t/e];return[1,t]}function x(e){const r=new Uint32Array(e);for(let t=0;t<e;++t)r[t]=t;return t(r),r}function N(t,e){return e<=t.length?t:t+" ".repeat(e-t.length)}function m(t,e=(t=>0),r){return new Promise((n,o)=>{let s=0;const a=()=>{if(t())return void n();const i=e(++s);null!=r&&s>=r?o():setTimeout(a,i)};setTimeout(a,0)})}function y(t){const e={};return t.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(t,...r)=>(g(e,r[0],r[1]),r.join("="))),e}function g(t,e,r){t[decodeURIComponent(e)]=decodeURIComponent(r||"")}function w(t,e){let r=1,n=-1;for(let e=0;e<t.length;++e)if(t[e]>0)r*=t[e];else if(-1===t[e]){if(-1!==n)throw Error("Shapes can only have 1 implicit size. "+`Found -1 at dim ${n} and dim ${e}`);n=e}else if(t[e]<=0)throw Error(`Shapes can not be <= 0. Found ${t[e]} at dim ${e}`);if(-1===n){if(e>0&&e!==r)throw Error(`Size (${e}) must match the product of shape ${t}`);return t}if(e%r!=0)throw Error("The implicit shape can't be a fractional number. "+`Got ${e} / ${r}`);const o=t.slice();return o[n]=e/r,o}function A(t){if("float32"===t)return exports.NAN_FLOAT32;if("int32"===t)return exports.NAN_INT32;if("bool"===t)return exports.NAN_BOOL;throw new Error(`Unknown dtype ${t}`)}function S(t,e){if(isNaN(t))return!0;if("float32"===e)return!1;if("int32"===e)return t===exports.NAN_INT32;if("bool"===e)return t===exports.NAN_BOOL;throw new Error(`Unknown dtype ${e}`)}function T(t){const e=[],r=[];for(let n=0;n<t.length;++n)t[n]>1&&(e.push(t[n]),r.push(n));return{newShape:e,keptDims:r}}function $(t,e){let r=null;if(null==t||"float32"===t)r=new Float32Array(e);else if("int32"===t)r=new Int32Array(e);else{if("bool"!==t)throw new Error(`Unknown data type ${t}`);r=new Uint8Array(e)}return r}function M(t,e){for(let r=0;r<e.length;r++)if(e[r].id===t.id)return!0;return!1}function E(t,e,r){for(let n=0;n<t.length;n++)if(S(t[n],e))throw Error(`The result of the last math.${r} has NaNs.`)}function b(t,e){const r=[];if(t instanceof F.NDArray)r.push(t);else{const n=t;for(let t=0;t<e.length;t++)r.push(n[e[t]])}return r}function I(t,e){if(t.length!==e.length)throw new Error("Cannot unflatten NDArray[], keys and arrays are not of same length.");const r={};for(let n=0;n<t.length;n++)r[t[n]]=e[n];return r}function _(t,e){return"float32"!==e&&(("int32"!==e||"float32"===t)&&("bool"!==e||"bool"!==t))}Object.defineProperty(exports,"__esModule",{value:!0});const F=require("./math/ndarray");exports.shuffle=t,exports.clamp=e,exports.randUniform=r,exports.distSquared=n,exports.assert=o,exports.assertShapesMatch=s,exports.assertTypesMatch=a,exports.flatten=i,exports.inferShape=u,exports.sizeFromShape=f,exports.isScalarShape=l,exports.arraysEqual=p,exports.isInt=h,exports.tanh=c,exports.sizeToSquarishShape=d,exports.createShuffledIndices=x,exports.rightPad=N,exports.repeatedTry=m,exports.getQueryParams=y,exports.inferFromImplicitShape=w,exports.NAN_INT32=1<<31,exports.NAN_BOOL=255,exports.NAN_FLOAT32=NaN,exports.getNaN=A,exports.isValNaN=S,exports.squeezeShape=T,exports.getTypedArrayFromDType=$,exports.isNDArrayInList=M,exports.checkForNaN=E,exports.flattenNameArrayMap=b,exports.unflattenToNameArrayMap=I,exports.hasEncodingLoss=_;
},{"./math/ndarray":17}],28:[function(require,module,exports) {
"use strict";function e(e,n){for(let t=0;t<e.length;++t)if(e[e.length-t-1]!==n-1-t)return!1;return!0}function n(e,n,t){const r=e.length+n.length,o=[];let s=0,u=0;for(let p=0;p<r;p++)-1===t.indexOf(p)?o.push(e[s++]):o.push(n[u++]);return o}function t(e,n){const t=[],r=e.length;for(let o=0;o<r;o++)-1===n.indexOf(o)&&t.push(e[o]);return[t,n.map(n=>e[n])]}function r(e,t){return n(e,t.map(e=>1),t)}function o(e,n){null==e?e=n.map((e,n)=>n):"number"==typeof e&&(e=[e]);const t=n.length;return e.forEach((e,n)=>{if(e<-t||e>=t)throw new Error("Axis must be between -rank and rank-1. "+`Got axis[${n}]=${e} where rank is ${t}`)}),e.map(e=>e<0?t+e:e)}function s(n,t,r){if(!e(t,r))throw new Error(`${n} supports only inner-most axes for now. `+`Got axes ${t} and rank-${r} input.`)}function u(n,t){if(e(n,t))return null;const r=[];for(let e=0;e<t;++e)-1===n.indexOf(e)&&r.push(e);return n.forEach(e=>r.push(e)),r}function p(e,n){const t=[];for(let r=n-e;r<n;++r)t.push(r);return t}Object.defineProperty(exports,"__esModule",{value:!0}),exports.axesAreInnerMostDims=e,exports.combineLocations=n,exports.computeOutAndReduceShapes=t,exports.expandShapeToKeepDim=r,exports.parseAxisParam=o,exports.assertAxesAreInnerMostDims=s,exports.getPermutedAxes=u,exports.getInnerMostAxes=p;
},{}],32:[function(require,module,exports) {
"use strict";function t(t){if(null==t)return[];if(t instanceof c.NDArray)return[t];const e=[],s=t;for(const t in s){if(!s.hasOwnProperty(t))continue;const o=s[t];o instanceof c.NDArray&&e.push(o)}return e}Object.defineProperty(exports,"__esModule",{value:!0});const e=require("../../util"),c=require("../ndarray");exports.extractNDArraysFromScopeResult=t;class s{constructor(){this.activeScope=[],this.scopeStack=[this.activeScope]}scope(t,e){this.startScope();const c=e();return this.endScope(c),c}startScope(){const t=[];this.scopeStack.push(t),this.activeScope=t}endScope(c){const s=t(c);for(let t=0;t<this.activeScope.length;t++){const c=this.activeScope[t];e.isNDArrayInList(c,s)||c.dispose()}this.scopeStack.pop(),this.activeScope=0===this.scopeStack.length?null:this.scopeStack[this.scopeStack.length-1],s.forEach(t=>{this.track(t)})}track(t){return this.scopeStack.length>1&&this.activeScope.push(t),t}}exports.BackendEngine=s;
},{"../../util":24,"../ndarray":17}],27:[function(require,module,exports) {
"use strict";function t(t,e){const r=t.length,n=[];for(let o=0;o<r;o++){const s=r-1-o,a=t[s]||1;(e[e.length-1-o]||1)>1&&1===a&&n.unshift(s)}return n}function e(t){for(let e=0;e<t.length;e++)if(t[e]!==e)return!1;return!0}function r(t,e){const r=[],n="Operands could not be broadcast together with shapes "+`${t} and ${e}.`,o=Math.max(t.length,e.length);for(let s=0;s<o;s++){const o=t[t.length-s-1]||1,a=e[e.length-s-1]||1;if(o>1&&a>1&&o!==a)throw Error(n);r.unshift(Math.max(o,a))}return r}Object.defineProperty(exports,"__esModule",{value:!0}),exports.getBroadcastDims=t,exports.broadcastDimsAreOuter=e,exports.assertAndGetBroadcastShape=r;
},{}],29:[function(require,module,exports) {
"use strict";function e(e,t,s){const r=e.length,a=t.length;n.assert(e.length===t.length,`Error in concat${r}D: rank of x1 (${r}) and x2 (${a}) `+"must be the same."),n.assert(s>=0&&s<r,`Error in concat${r}D: axis must be `+`between 0 and ${r-1}.`);for(let a=0;a<r;a++)n.assert(a===s||e[a]===t[a],`Error in concat${r}D: Shape (${e}) does not match `+`(${t}) along the non-concatenated axis ${a}.`)}function t(e,t,s){n.assert(e.length===t.length,"x1 and x2 should have the same rank.");const r=e.slice();return r[s]+=t[s],r}Object.defineProperty(exports,"__esModule",{value:!0});const n=require("../util");exports.assertParams=e,exports.computeOutShape=t;
},{"../util":24}],30:[function(require,module,exports) {
"use strict";function t(t,n,o,r,a="channelsLast"){const[s,h]=i(n);let u;if("channelsLast"===a)u=[s,h,t[3],t[3]];else{if("channelsFirst"!==a)throw new Error(`Unknown dataFormat ${a}`);u=[s,h,t[1],t[1]]}return e(t,u,o,r,!1,a)}function e(t,e,n,o,r=!1,a="channelsLast"){let[h,u,l,c]=[-1,-1,-1,-1];if("channelsLast"===a)[h,u,l,c]=t;else{if("channelsFirst"!==a)throw new Error(`Unknown dataFormat ${a}`);[h,c,u,l]=t}const[p,f,,d]=e,[m,g]=i(n),{padInfo:b,outHeight:w,outWidth:M}=s(o,u,l,m,g,p,f),x=r?d*c:d;let I;return"channelsFirst"===a?I=[h,x,w,M]:"channelsLast"===a&&(I=[h,w,M,x]),{batchSize:h,inHeight:u,inWidth:l,inChannels:c,outHeight:w,outWidth:M,outChannels:x,dataFormat:a,strideHeight:m,strideWidth:g,filterHeight:p,filterWidth:f,padInfo:b,inShape:t,outShape:I,filterShape:e}}function n(t,e,n,r,a){null==a&&(a=o(t,e,r));const i=t[0],s=t[1],u=(i-e+2*a)/r+1;h.assert(h.isInt(u),`The output # of rows (${u}) must be an integer. Change the `+"stride and/or zero pad parameters");const l=(s-e+2*a)/r+1;return h.assert(h.isInt(l),`The output # of columns (${l}) must be an integer. Change `+"the stride and/or zero pad parameters"),[u,l,n]}function o(t,e,n){return Math.floor((t[0]*(n-1)-n+e)/2)}function r(t,e,n,o){return[n,o,t,e]}function a(t,e){return[(t[0]-1)*e+1,(t[1]-1)*e+1]}function i(t){return"number"==typeof t?[t,t]:t}function s(t,e,o,r,a,i,s){let h,u,l;if("number"==typeof t){h={top:t,bottom:t,left:t,right:t};const a=n([e,o,1],i,1,r,t);u=a[0],l=a[1]}else if("same"===t){const t=((u=Math.ceil(e/r))-1)*r+i-e,n=((l=Math.ceil(o/a))-1)*a+s-o,c=Math.floor(t/2),p=t-c,f=Math.floor(n/2);h={top:c,bottom:p,left:f,right:n-f}}else{if("valid"!==t)throw Error(`Unknown padding parameter: ${t}`);h={top:0,bottom:0,left:0,right:0},u=Math.ceil((e-i+1)/r),l=Math.ceil((o-s+1)/a)}return{padInfo:h,outHeight:u,outWidth:l}}Object.defineProperty(exports,"__esModule",{value:!0});const h=require("../util");exports.computePool2DInfo=t,exports.computeConv2DInfo=e,exports.computeOutputShape3D=n,exports.computeDefaultPad=o,exports.computeWeightsShape4D=r,exports.computeDilatedRC=a;
},{"../util":24}],31:[function(require,module,exports) {
"use strict";function r(r,a,t){e.assert(r.rank===a.length,`Error in slice${r.rank}D: Length of begin ${a} must `+`match the rank of the array (${r.rank}).`),e.assert(r.rank===t.length,`Error in slice${r.rank}D: Length of size ${t} must `+`match the rank of the array (${r.rank}).`);for(let s=0;s<r.rank;++s)e.assert(a[s]+t[s]<=r.shape[s],`Error in slice${r.rank}D: begin[${s}] + size[${s}] `+`(${a[s]+t[s]}) would overflow input.shape[${s}] (${r.shape[s]})`)}Object.defineProperty(exports,"__esModule",{value:!0});const e=require("../util");exports.assertParamsValid=r;
},{"../util":24}],19:[function(require,module,exports) {
"use strict";function t(t,o){return r[t][o]}Object.defineProperty(exports,"__esModule",{value:!0});var o;!function(t){t[t.REGULAR=0]="REGULAR",t[t.TRANSPOSED=1]="TRANSPOSED"}(o=exports.MatrixOrientation||(exports.MatrixOrientation={}));var a;!function(t){t.float32="float32",t.int32="int32",t.bool="int32"}(a=exports.SumTypesMap||(exports.SumTypesMap={}));var n;!function(t){t.bool="bool",t.float32="float32",t.int32="int32"}(n=exports.UpcastBoolAndMap||(exports.UpcastBoolAndMap={}));var p;!function(t){t.bool="float32",t.float32="float32",t.int32="float32"}(p=exports.UpcastFloat32AndMap||(exports.UpcastFloat32AndMap={}));var e;!function(t){t.bool="int32",t.float32="float32",t.int32="int32"}(e=exports.UpcastInt32AndMap||(exports.UpcastInt32AndMap={}));const r={bool:n,float32:p,int32:e};exports.upcastType=t;
},{}],18:[function(require,module,exports) {
"use strict";function r(r){return"number"==typeof r?[r,r]:r}Object.defineProperty(exports,"__esModule",{value:!0});const t=require("../environment"),e=require("../util"),a=require("./axis_util"),s=require("./backends/backend_engine"),n=require("./broadcast_util"),i=require("./concat_util"),o=require("./conv_util"),h=require("./ndarray"),u=require("./slice_util"),p=require("./types");class c{constructor(r){this.registeredArrays=new WeakMap,this.registeredArrayCount=0,this.customBackend=!1,"string"==typeof r?this.backend=t.ENV.getBackend(r):(this.customBackend=!0,this.backend=r),this.backendEngine=new s.BackendEngine}time(r){return this.backend.time(r)}getNumArrays(){return this.registeredArrayCount}register(r){const t=this.registeredArrays.has(r.dataId)?this.registeredArrays.get(r.dataId):0;0===t&&(this.backend.register(r.dataId,r.shape,r.dtype),this.registeredArrayCount++),this.registeredArrays.set(r.dataId,t+1),this.backendEngine.track(r)}writePixels(r,t,e){this.backend.writePixels(r,t,e)}write(r,t){this.backend.write(r,t)}readSync(r){return this.backend.readSync(r)}read(r){return this.backend.read(r)}scope(r){return this.backendEngine.scope("scope",r)}startScope(){this.backendEngine.startScope()}endScope(r){this.backendEngine.endScope(r)}dispose(){this.customBackend&&this.backend.dispose()}matMul(r,t,a=p.MatrixOrientation.REGULAR,s=p.MatrixOrientation.REGULAR){const n=a===p.MatrixOrientation.REGULAR?r.shape[1]:r.shape[0],i=s===p.MatrixOrientation.REGULAR?t.shape[0]:t.shape[1];return e.assert(2===r.rank&&2===t.rank,`Error in matMul: inputs must be rank 2, got ranks ${r.rank}`+` and ${t.rank}.`),e.assert(n===i,`Error in matMul: inner shapes (${n}) and (`+`${i}) of NDArrays with shapes ${r.shape} and `+`${t.shape} and orientations ${p.MatrixOrientation[a]}`+` and ${p.MatrixOrientation[s]} must match.`),this.backend.matMul(r,t,a,s)}executeOp(r,t){return t()}vectorTimesMatrix(r,t){return e.assert(1===r.rank,"Error in vectorTimesMatrix: first input must be rank 1, but got "+`rank ${r.rank}.`),e.assert(2===t.rank,"Error in vectorTimesMatrix: second input must be rank 2, but got "+`rank ${t.rank}.`),e.assert(r.size===t.shape[0],`Error in vectorTimesMatrix: size of vector (${r.size}) `+`must match first dimension of matrix (${t.shape[0]})`),this.matMul(r.as2D(1,-1),t).as1D()}matrixTimesVector(r,t){return e.assert(1===t.rank,"Error in matrixTimesVector: second input must rank 1, but got "+`rank ${t.rank}.`),e.assert(2===r.rank,"Error in matrixTimesVector: first input must be a rank 2, but got "+`rank ${r.rank}.`),e.assert(t.size===r.shape[1],`Error in matrixTimesVector: size of first rank 1 input ${t.size} `+"must match inner dimension of second rank 2 input, but got "+`shape ${r.shape}.`),this.matMul(r,t.as2D(-1,1)).as1D()}dotProduct(r,t){return e.assert(1===r.rank&&1===t.rank,"Error in dotProduct: inputs must be rank 1, but got ranks "+`${r.rank} and ${t.rank}.`),e.assert(r.size===t.size,`Error in dotProduct: size of inputs (${r.size}) and (`+`${t.size}) must match.`),this.matMul(r.as2D(1,-1),t.as2D(-1,1)).asScalar()}outerProduct(r,t){return e.assert(1===r.rank&&1===t.rank,"Error in outerProduct: inputs must be rank 1, but got ranks "+`${r.rank} and ${t.rank}.`),this.matMul(r.as2D(-1,1),t.as2D(1,-1))}clone(r){return this.backend.clone(r)}reshape(r,t){return t=e.inferFromImplicitShape(t,r.size),e.assert(r.size===e.sizeFromShape(t),"new shape and old shape must have the same number of elements."),h.NDArray.make(t,{dataId:r.dataId},r.dtype)}cast(r,t){if(!e.hasEncodingLoss(r.dtype,t))return h.NDArray.make(r.shape,{dataId:r.dataId},t);if("int32"===t)return this.backend.int(r);if("bool"===t)return this.backend.notEqual(r,h.Scalar.new(0,r.dtype));throw new Error(`Error in Cast: unknown dtype argument (${t})`)}slice1D(r,t,e){return u.assertParamsValid(r,[t],[e]),this.backend.slice1D(r,t,e)}slice2D(r,t,e){return u.assertParamsValid(r,t,e),this.backend.slice2D(r,t,e)}slice3D(r,t,e){return u.assertParamsValid(r,t,e),this.backend.slice3D(r,t,e)}slice4D(r,t,e){return u.assertParamsValid(r,t,e),this.backend.slice4D(r,t,e)}concat1D(r,t){return i.assertParams(r.shape,t.shape,0),this.backend.concat1D(r,t)}concat2D(r,t,e){return i.assertParams(r.shape,t.shape,e),this.backend.concat2D(r,t,e)}concat3D(r,t,e){return i.assertParams(r.shape,t.shape,e),this.backend.concat3D(r,t,e)}concat4D(r,t,e){return i.assertParams(r.shape,t.shape,e),this.backend.concat4D(r,t,e)}logSumExp(r,t=null,e=!1){const s=a.parseAxisParam(t,r.shape);return this.executeOp("logSumExp",()=>{const t=this.max(r,s,!0),n=this.subtract(r,t),i=this.exp(n),o=this.sum(i,s),h=this.log(o),u=this.add(t.reshape(h.shape),h);if(e){const r=a.expandShapeToKeepDim(u.shape,s);return u.reshape(r)}return u})}sum(r,t=null,e=!1){const s=a.parseAxisParam(t,r.shape);let n=s;const i=a.getPermutedAxes(n,r.rank);return this.executeOp("sum",()=>{null!=i&&(r=this.transpose(r,i),n=a.getInnerMostAxes(n.length,r.rank));const t=this.backend.sum(r,n);if(e){const r=a.expandShapeToKeepDim(t.shape,s);return t.reshape(r)}return t})}mean(r,t=null,s=!1){const n=a.parseAxisParam(t,r.shape),i=a.computeOutAndReduceShapes(r.shape,n)[1],o=e.sizeFromShape(i);return this.executeOp("mean",()=>this.scope(()=>{const e=this.divide(r,h.Scalar.new(o));return this.sum(e,t,s)}))}argMin(r,t=null){let e=a.parseAxisParam(t,r.shape);const s=a.getPermutedAxes(e,r.rank);return this.executeOp("argMin",()=>(null!=s&&(r=this.transpose(r,s),e=a.getInnerMostAxes(e.length,r.rank)),this.backend.argMin(r,e)))}argMax(r,t=null){let e=a.parseAxisParam(t,r.shape);const s=a.getPermutedAxes(e,r.rank);return this.executeOp("argMax",()=>(null!=s&&(r=this.transpose(r,s),e=a.getInnerMostAxes(e.length,r.rank)),this.backend.argMax(r,e)))}argMaxEquals(r,t){return e.assertShapesMatch(r.shape,t.shape,"Error in argMaxEquals: "),this.executeOp("argMaxEquals",()=>this.scope(()=>this.equal(this.argMax(r),this.argMax(t))))}equal(r,t){return e.assertTypesMatch(r,t),n.assertAndGetBroadcastShape(r.shape,t.shape),this.backend.equal(r,t)}equalStrict(r,t){return e.assertShapesMatch(r.shape,t.shape,"Error in equalStrict: "),this.equal(r,t)}notEqual(r,t){return e.assertTypesMatch(r,t),n.assertAndGetBroadcastShape(r.shape,t.shape),this.backend.notEqual(r,t)}notEqualStrict(r,t){return e.assertShapesMatch(r.shape,t.shape,"Error in notEqualStrict: "),this.notEqual(r,t)}greater(r,t){return this.backend.greater(r,t)}greaterEqual(r,t){return this.backend.greaterEqual(r,t)}less(r,t){return this.backend.less(r,t)}lessEqual(r,t){return this.backend.lessEqual(r,t)}select(r,t,e){return this.backend.select(r,t,e)}topK(r,t){e.assert(t<=r.size,`Error in topK: k value (${t}) must be less than size of input `+`ndarray, got shape ${r.shape}.`);let a,s;this.executeOp("topK",()=>(a=this.backend.topKValues(r,t),s=this.backend.topKIndices(r,t),a));return{values:a,indices:s}}min(r,t=null,e=!1){const s=a.parseAxisParam(t,r.shape);let n=s;const i=a.getPermutedAxes(n,r.rank);return this.executeOp("min",()=>{null!=i&&(r=this.transpose(r,i),n=a.getInnerMostAxes(n.length,r.rank));const t=this.backend.min(r,n);if(e){const r=a.expandShapeToKeepDim(t.shape,s);return t.reshape(r)}return t})}minimum(r,t){return e.assertTypesMatch(r,t),n.assertAndGetBroadcastShape(r.shape,t.shape),this.backend.minimum(r,t)}max(r,t=null,e=!1){const s=a.parseAxisParam(t,r.shape);let n=s;const i=a.getPermutedAxes(n,r.rank);return this.executeOp("max",()=>{null!=i&&(r=this.transpose(r,i),n=a.getInnerMostAxes(n.length,r.rank));const t=this.backend.max(r,n);if(e){const r=a.expandShapeToKeepDim(t.shape,s);return t.reshape(r)}return t})}maximum(r,t){return e.assertTypesMatch(r,t),n.assertAndGetBroadcastShape(r.shape,t.shape),this.backend.maximum(r,t)}softmax(r,t=-1){if(-1===t&&(t=r.rank-1),t!==r.rank-1)throw Error("Softmax along a non-last dimension is not yet supported. "+`Logits was rank ${r.rank} and dim was ${t}`);return this.executeOp("softmax",()=>{const e=this.logSumExp(r,[t],!0),a=this.subtract(r,e);return this.exp(a)})}softmaxCrossEntropyWithLogits(r,t,a=-1){if(e.assertShapesMatch(r.shape,t.shape,"Error in softmaxCrossEntropyWithLogits: "),-1===a&&(a=t.rank-1),a!==t.rank-1)throw Error("Softmax cross entropy along a non-last dimension is not yet "+`supported. Labels / logits was rank ${t.rank} `+`and dim was ${a}`);return this.executeOp("softmaxCrossEntropyWithLogits",()=>{const e=this.softmax(t,a),s=this.add(h.Scalar.new(1e-5),e),n=this.log(s),i=this.multiply(r,n),o=this.neg(i);return this.sum(o,[a])})}switchDim(r,t){return this.transpose(r,t)}tile(r,t){return e.assert(r.rank===t.length,`Error in transpose: rank of input ${r.rank} `+`must match length of reps ${t}.`),this.backend.tile(r,t)}transpose(r,t){return null==t&&(t=r.shape.map((r,t)=>t).reverse()),e.assert(r.rank===t.length,`Error in transpose: rank of input ${r.rank} `+`must match length of perm ${t}.`),this.backend.transpose(r,t)}scalarPlusArray(r,t){return e.assert(1===r.size,"Error in scalarPlusArray: first argument must be rank 0, but got "+`rank ${r.rank}.`),this.add(r,t)}scalarMinusArray(r,t){return e.assert(1===r.size,"Error in scalarMinusArray: first argument must be rank 0, but got "+`rank ${r.rank}.`),this.subtract(r,t)}arrayMinusScalar(r,t){return e.assert(1===t.size,"Error in arrayMinusScalar: second argument must be rank 0, but "+`got rank ${t.rank}.`),this.subtract(r,t)}neg(r){return this.backend.neg(r)}add(r,t){return e.assertTypesMatch(r,t),n.assertAndGetBroadcastShape(r.shape,t.shape),this.backend.add(r,t)}addStrict(r,t){return e.assertShapesMatch(r.shape,t.shape,"Error in addStrict: "),this.add(r,t)}subtract(r,t){return e.assertTypesMatch(r,t),n.assertAndGetBroadcastShape(r.shape,t.shape),this.backend.subtract(r,t)}pow(r,t){return e.assert("int32"===t.dtype,"only supports int32 data type for the exponent parameter."),n.assertAndGetBroadcastShape(r.shape,t.shape),this.backend.pow(r,t)}powStrict(r,t){return e.assertShapesMatch(r.shape,t.shape,"Error in powStrict: "),this.pow(r,t)}sub(r,t){return this.subtract(r,t)}subStrict(r,t){return e.assertShapesMatch(r.shape,t.shape,"Error in subStrict: "),this.subtract(r,t)}multiply(r,t){return e.assertTypesMatch(r,t),n.assertAndGetBroadcastShape(r.shape,t.shape),this.backend.multiply(r,t)}elementWiseMul(r,t){return this.multiplyStrict(r,t)}multiplyStrict(r,t){return e.assertShapesMatch(r.shape,t.shape,"Error in multiplyStrict: "),this.multiply(r,t)}divide(r,t){return n.assertAndGetBroadcastShape(r.shape,t.shape),this.backend.divide(r,t)}divideStrict(r,t){return e.assertShapesMatch(r.shape,t.shape,"Error in divideStrict: "),this.divide(r,t)}scalarDividedByArray(r,t){return e.assert(1===r.size,"Error in scalarDividedByArray: first argument must be rank 0, but "+`got NDArray of rank ${r.rank}.`),this.divide(r,t)}arrayDividedByScalar(r,t){return e.assert(1===t.size,"Error in arrayDividedByScalar: second argument must be rank 0, "+`but got NDArray of rank ${t.rank}.`),this.divide(r,t)}ceil(r){return this.backend.ceil(r)}floor(r){return this.backend.floor(r)}exp(r){return this.backend.exp(r)}log(r){return this.backend.log(r)}sqrt(r){return this.backend.sqrt(r)}square(r){return this.backend.square(r)}abs(r){return this.backend.abs(r)}clip(r,t,a){return e.assert(t<=a,`Error in clip: min (${t}) must be`+`less than or equal to max (${a}).`),this.backend.clip(r,t,a)}relu(r){return this.backend.relu(r)}elu(r){return this.backend.elu(r)}eluDer(r){return this.backend.eluDer(r)}selu(r){return this.backend.selu(r)}leakyRelu(r,t=.2){return this.backend.leakyRelu(r,t)}prelu(r,t){return this.backend.prelu(r,t)}preluDer(r,t){return this.backend.preluDer(r,t)}sigmoid(r){return this.backend.sigmoid(r)}sin(r){return this.backend.sin(r)}cos(r){return this.backend.cos(r)}tan(r){return this.backend.tan(r)}asin(r){return this.backend.asin(r)}acos(r){return this.backend.acos(r)}atan(r){return this.backend.atan(r)}sinh(r){return this.backend.sinh(r)}cosh(r){return this.backend.cosh(r)}tanh(r){return this.backend.tanh(r)}step(r,t=0){return this.backend.step(r,t)}scaledArrayAdd(r,t,a,s){return e.assert(1===r.size,"Error in scaledArrayAdd: first argument must rank 0, but got "+` rank ${r.rank}.`),e.assert(1===a.size,"Error in scaledArrayAdd: third argument must be rank 0, but got "+`NDArray of rank ${a.rank}.`),e.assertShapesMatch(t.shape,s.shape,"Error in scaledArrayAdd: "),this.executeOp("scaledArrayAdd",()=>this.scope(()=>this.add(this.multiply(r,t),this.multiply(a,s))))}scalarTimesArray(r,t){return e.assert(1===r.size,"Error in arrayDividedByScalar: first argument must be rank 0, but "+`got rank ${r.rank}.`),this.multiply(r,t)}elementWiseMulBroadcast(r,t){return e.assert(2===r.rank,"Error in elementWiseMulBroadcast: first argument must be "+`rank 2, but got rank ${r.rank}.`),e.assert(2===t.rank,"Error in elementWiseMulBroadcast: second argument must be "+`rank 2, but got rank ${t.rank}.`),this.multiply(r,t)}conv1d(r,t,a,s,n){let i=r,o=!1;2===r.rank&&(o=!0,i=r.as3D(1,r.shape[0],r.shape[1])),e.assert(3===i.rank,`Error in conv1d: input must be rank 3, but got rank ${i.rank}.`),e.assert(3===t.rank,"Error in conv1d: filter must be rank 3, but got rank "+`${t.rank}.`),null!=a&&e.assert(1===a.rank,"Error in conv1d: bias must be rank 1, but got rank "+`${a.rank}.`),e.assert(i.shape[2]===t.shape[1],`Error in conv1d: depth of input (${i.shape[2]}) must match  `+`input depth for filter ${t.shape[1]}.`);const h=t.as4D(1,t.shape[0],t.shape[1],t.shape[2]),u=i.as4D(i.shape[0],1,i.shape[1],i.shape[2]),p=[1,s];return this.executeOp("Conv1D",()=>{const r=this.conv2d(u,h,a,p,n);return o?r.as2D(r.shape[2],r.shape[3]):r.as3D(r.shape[0],r.shape[2],r.shape[3])})}conv2d(r,t,a,s,n){let i=r,h=!1;3===r.rank&&(h=!0,i=r.as4D(1,r.shape[0],r.shape[1],r.shape[2])),e.assert(4===i.rank,`Error in conv2d: input must be rank 4, but got rank ${i.rank}.`),e.assert(4===t.rank,"Error in conv2d: filter must be rank 4, but got rank "+`${t.rank}.`),null!=a&&e.assert(1===a.rank,"Error in conv2d: bias must be rank 1, but got rank "+`${a.rank}.`),e.assert(i.shape[3]===t.shape[2],`Error in conv2d: depth of input (${i.shape[3]}) must match  `+`input depth for filter ${t.shape[2]}.`);const u=o.computeConv2DInfo(i.shape,t.shape,s,n);return this.executeOp("Conv2D",()=>{const r=this.backend.conv2d(i,t,a,u);return h?r.as3D(r.shape[1],r.shape[2],r.shape[3]):r})}conv2dDerInput(r,t,a,s,n){e.assert(r.length===t.rank,"Length of inShape "+`(${r.length}) and rank of dy (${t.rank}) must match`);let i=r,h=t,u=!1;3===t.rank&&(u=!0,h=t.as4D(1,t.shape[0],t.shape[1],t.shape[2]),i=[1,r[0],r[1],r[2]]);const p=i[3],c=h.shape[3];e.assert(4===i.length,"Error in conv2dDerInput: inShape must be length 4, but got length "+`${i.length}.`),e.assert(4===h.rank,"Error in conv2dDerInput: dy must be rank 4, but got "+`rank ${h.rank}`),e.assert(4===a.rank,"Error in conv2dDerInput: filter must be rank 4, but got "+`rank ${a.rank}`),e.assert(p===a.shape[2],`Error in conv2dDerInput: depth of input (${p}) must `+`match input depth for filter ${a.shape[2]}.`),e.assert(c===a.shape[3],`Error in conv2dDerInput: depth of output (${c}) must`+`match output depth for filter ${a.shape[3]}.`);const k=o.computeConv2DInfo(i,a.shape,s,n);return this.executeOp("conv2dDerInput",()=>{const r=this.backend.conv2dDerInput(h,a,k);return u?r.as3D(r.shape[1],r.shape[2],r.shape[3]):r})}conv2dDerBias(r){let t=r;return 3===r.rank&&(t=r.as4D(1,r.shape[0],r.shape[1],r.shape[2])),this.backend.conv2dDerBias(t)}conv2dDerFilter(r,t,a,s,n){let i=r;3===r.rank&&(i=r.as4D(1,r.shape[0],r.shape[1],r.shape[2]));let h=t;3===h.rank&&(h=t.as4D(1,t.shape[0],t.shape[1],t.shape[2])),e.assert(4===i.rank,"Error in conv2dDerFilter: input must be rank 4, but got shape "+`${i.shape}.`),e.assert(4===h.rank,"Error in conv2dDerFilter: dy must be rank 4, but got shape "+`${h.shape}.`),e.assert(4===a.length,"Error in conv2dDerFilter: filterShape must be length 4, but got "+`${a}.`),e.assert(i.shape[3]===a[2],`Error in conv2dDerFilter: depth of input ${i.shape[3]}) must `+`match input depth in filter (${a[2]}.`),e.assert(h.shape[3]===a[3],`Error in conv2dDerFilter: depth of dy (${h.shape[3]}) must `+`match output depth for filter (${a[3]}).`);const u=o.computeConv2DInfo(i.shape,a,s,n);return this.backend.conv2dDerFilter(i,h,u)}conv2dTranspose(r,t,e,a,s){return this.conv2dDerInput(e,r,t,a,s)}depthwiseConv2D(t,a,s,n,i=[1,1]){let h=t,u=!1;3===t.rank&&(u=!0,h=t.as4D(1,t.shape[0],t.shape[1],t.shape[2])),e.assert(4===h.rank,"Error in depthwiseConv2D: input must be rank 4, but got "+`rank ${h.rank}.`),e.assert(4===a.rank,"Error in depthwiseConv2D: filter must be rank 4, but got rank "+`${a.rank}.`),e.assert(h.shape[3]===a.shape[2],"Error in depthwiseConv2D: number of input channels "+`(${h.shape[3]}) must match the inChannels dimension in `+`filter ${a.shape[2]}.`),i=i||[1,1];const[p,c]=r(i);e.assert(1===p&&1===c,"Error in depthwiseConv2D: rates greater than 1 are not yet "+`supported. Got rates '${i}'`);const k=o.computeConv2DInfo(h.shape,a.shape,s,n,!0);return this.executeOp("depthwiseConv2D",()=>{const r=this.backend.depthwiseConv2D(h,a,k);return u?r.as3D(r.shape[1],r.shape[2],r.shape[3]):r})}maxPool(r,t,a,s){let n=r,i=!1;3===r.rank&&(i=!0,n=r.as4D(1,r.shape[0],r.shape[1],r.shape[2])),e.assert(4===n.rank,`Error in maxPool: input must be rank 4 but got rank ${n.rank}.`);const h=o.computePool2DInfo(n.shape,t,a,s);return this.executeOp("maxPool",()=>{const r=this.backend.maxPool(n,h);return i?r.as3D(r.shape[1],r.shape[2],r.shape[3]):r})}maxPoolBackprop(r,t,a,s,n){e.assert(t.rank===r.rank,`Rank of input (${t.rank}) does not match rank of dy (${r.rank})`);let i=t,h=r,u=!1;3===t.rank&&(u=!0,i=t.as4D(1,t.shape[0],t.shape[1],t.shape[2]),h=r.as4D(1,r.shape[0],r.shape[1],r.shape[2])),e.assert(4===h.rank,"Error in maxPoolBackprop: dy must be rank 4 but got rank "+`${h.rank}.`),e.assert(4===i.rank,"Error in maxPoolBackprop: input must be rank 4 but got rank "+`${i.rank}.`);const p=o.computePool2DInfo(i.shape,a,s,n);return this.executeOp("maxPoolBackprop",()=>{const r=this.backend.maxPoolBackprop(h,i,p);return u?r.as3D(r.shape[1],r.shape[2],r.shape[3]):r})}minPool(r,t,a,s){let n=r,i=!1;3===r.rank&&(i=!0,n=r.as4D(1,r.shape[0],r.shape[1],r.shape[2])),e.assert(4===n.rank,`Error in minPool: x must be rank 4 but got rank ${n.rank}.`);const h=o.computePool2DInfo(n.shape,t,a,s);return this.executeOp("minPool",()=>{const r=this.backend.minPool(n,h);return i?r.as3D(r.shape[1],r.shape[2],r.shape[3]):r})}avgPool(r,t,a,s){let n=r,i=!1;3===r.rank&&(i=!0,n=r.as4D(1,r.shape[0],r.shape[1],r.shape[2])),e.assert(4===n.rank,`Error in avgPool: x must be rank 4 but got rank ${n.rank}.`);const h=o.computePool2DInfo(n.shape,t,a,s);return this.executeOp("avgPool",()=>{const r=this.backend.avgPool(n,h);return i?r.as3D(r.shape[1],r.shape[2],r.shape[3]):r})}resizeBilinear3D(r,t,a=!1){return e.assert(3===r.rank,`Error in resizeBilinear3D: x must be rank 3 but got rank ${r.rank}.`),e.assert(2===t.length,"Error in resizeBilinear3D: new shape must 2D, but got shape "+`${t}.`),this.backend.resizeBilinear3D(r,t,a)}batchNormalization2D(r,t,a,s=.001,n,i){return e.assert(2===r.rank,"Error in batchNormalization3D: x must be rank 3 but got rank "+`${r.rank}.`),e.assert(2===t.rank||1===t.rank,"Error in batchNormalization2D: mean must be rank 2 or rank 1 but "+`got rank ${t.rank}.`),e.assert(2===a.rank||1===a.rank,"Error in batchNormalization2D: variance must be rank 2 or rank 1 "+`but got rank ${a.rank}.`),null!=n&&e.assert(2===n.rank||1===n.rank,"Error in batchNormalization2D: scale must be rank 2 or rank 1 "+`but got rank ${n.rank}.`),null!=i&&e.assert(2===i.rank||1===i.rank,"Error in batchNormalization2D: offset must be rank 2 or rank 1 "+`but got rank ${i.rank}.`),this.backend.batchNormalization2D(r,t,a,s,n,i)}batchNormalization3D(r,t,a,s=.001,n,i){return e.assert(3===r.rank,"Error in batchNormalization3D: x must be rank 3 but got rank "+`${r.rank}.`),e.assert(3===t.rank||1===t.rank,"Error in batchNormalization3D: mean must be rank 3 or rank 1 but "+`got rank ${t.rank}.`),e.assert(3===a.rank||1===a.rank,"Error in batchNormalization3D: variance must be rank 3 or rank 1 "+`but got rank ${a.rank}.`),null!=n&&e.assert(3===n.rank||1===n.rank,"Error in batchNormalization3D: scale must be rank 3 or rank 1 "+`but got rank ${n.rank}.`),null!=i&&e.assert(3===i.rank||1===i.rank,"Error in batchNormalization3D: offset must be rank 3 or rank 1 "+`but got rank ${i.rank}.`),this.backend.batchNormalization3D(r,t,a,s,n,i)}batchNormalization4D(r,t,a,s=.001,n,i){return e.assert(4===r.rank,"Error in batchNormalization4D: x must be rank 4 but got rank "+`${r.rank}.`),e.assert(4===t.rank||1===t.rank,"Error in batchNormalization4D: mean must be rank 4 or rank 1 but "+`got rank ${t.rank}.`),e.assert(4===a.rank||1===a.rank,"Error in batchNormalization4D: variance must be rank 4 or rank 1 "+`but got rank ${a.rank}.`),null!=n&&e.assert(4===n.rank||1===n.rank,"Error in batchNormalization4D: scale must be rank 4 or rank 1 "+`but got rank ${n.rank}.`),null!=i&&e.assert(4===i.rank||1===i.rank,"Error in batchNormalization4D: offset must be rank 4 or rank 1 "+`but got rank ${i.rank}.`),this.backend.batchNormalization4D(r,t,a,s,n,i)}multiRNNCell(r,t,e,a){const s=this.scope(()=>{let s=t;const n=[];for(let t=0;t<r.length;t++){const i=r[t](s,e[t],a[t]);n.push(i[0]),n.push(i[1]),s=i[1]}return n}),n=[],i=[];for(let r=0;r<s.length;r+=2)n.push(s[r]),i.push(s[r+1]);return[n,i]}basicLSTMCell(r,t,e,a,s,n){const i=this.scope(()=>{const i=this.concat2D(a,n,1),o=this.matMul(i,t),h=this.add(o,e),u=h.shape[0],p=h.shape[1]/4,c=[u,p],k=this.slice2D(h,[0,0],c),l=this.slice2D(h,[0,p],c),d=this.slice2D(h,[0,2*p],c),m=this.slice2D(h,[0,3*p],c),b=this.addStrict(this.multiplyStrict(s,this.sigmoid(this.scalarPlusArray(r,d))),this.multiplyStrict(this.sigmoid(k),this.tanh(l)));return[b,this.multiplyStrict(this.tanh(b),this.sigmoid(m))]});return[i[0],i[1]]}multinomial(r,t,e){const a=r.size;if(a<2)throw new Error("Error in multinomial: you need at least 2 outcomes, but got "+`${a}.`);if(r.rank>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${r.rank}`);e=e||Math.random();const s=r.rank;return 1===r.rank&&(r=r.as2D(1,-1)),this.executeOp("multinomial",()=>{const a=this.backend.multinomial(r,t,e);return 1===s?a.as1D():a})}oneHot(r,t,e=1,a=0){if(t<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${t}`);return this.backend.oneHot(r,t,e,a)}moments(r,t=null,e=!1){const s=a.parseAxisParam(t,r.shape);return this.scope(()=>{const t=this.mean(r,s,e);let n=t.shape;e||(n=a.expandShapeToKeepDim(t.shape,s));const i=this.square(this.subtract(r.asType("float32"),t.reshape(n)));return{mean:t,variance:this.mean(i,s,e)}})}norm(r,t="euclidean",e=null,s=!1){return this.scope(()=>{const n=this.normInternal(r,t,e);let i=n.shape;if(s){const t=a.parseAxisParam(e,r.shape);i=a.expandShapeToKeepDim(n.shape,t)}return n.reshape(i)})}setDiag(r,t){return this.backend.setDiag(r,t)}normInternal(r,t,e=null){if(0===r.rank)return this.abs(r);if(1!==r.rank&&null===e)return this.normInternal(r.reshape([-1]),t,e);if(1===r.rank||"number"==typeof e||e instanceof Array&&1===e.length){if(1===t)return this.sum(this.abs(r),e);if(t===1/0)return this.max(this.abs(r),e);if(t===-1/0)return this.min(this.abs(r),e);if("euclidean"===t||2===t)return this.sqrt(this.sum(this.pow(this.abs(r),h.Scalar.new(2,"int32")),e));throw new Error(`Error in norm: invalid ord value: ${t}`)}if(e instanceof Array&&2===e.length){if(1===t)return this.max(this.sum(this.abs(r),e[0]),e[1]-1);if(t===1/0)return this.max(this.sum(this.abs(r),e[1]),e[0]);if(t===-1/0)return this.min(this.sum(this.abs(r),e[1]),e[0]);if("fro"===t||"euclidean"===t)return this.sqrt(this.sum(this.pow(r,h.Scalar.new(2,"int32")),e));throw new Error(`Error in norm: invalid ord value: ${t}`)}throw new Error(`Error in norm: invalid axis: ${e}`)}disposeData(r){if(!this.registeredArrays.has(r))return;const t=this.registeredArrays.get(r);t<=1?(this.registeredArrays.delete(r),this.backend.disposeData(r),this.registeredArrayCount--):this.registeredArrays.set(r,t-1)}}exports.NDArrayMath=c;
},{"../environment":15,"../util":24,"./axis_util":28,"./backends/backend_engine":32,"./broadcast_util":27,"./concat_util":29,"./conv_util":30,"./ndarray":17,"./slice_util":31,"./types":19}],15:[function(require,module,exports) {
var global = (1,eval)("this");
function e(e){if(0===e)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const t=document.createElement("canvas");return 1===e?t.getContext("webgl")||t.getContext("experimental-webgl"):t.getContext("webgl2")}function t(e){if(null!=e){const t=e.getExtension("WEBGL_lose_context");if(null==t)throw new Error("Extension WEBGL_lose_context not supported on this browser.");t.loseContext()}}function n(n){const r=e(n);return null!=r&&(t(r),!0)}function r(n){const r=e(n),s=1===n?"EXT_disjoint_timer_query":"EXT_disjoint_timer_query_webgl2",i=null!=r.getExtension(s);return null!=r&&t(r),i}function s(n){if(0===n)return!1;const r=e(n);if(1===n){if(null==r.getExtension("OES_texture_float"))return!1}else if(null==r.getExtension("EXT_color_buffer_float"))return!1;const s=r.createFramebuffer(),i=r.createTexture();r.bindTexture(r.TEXTURE_2D,i);const o=2===n?r.RGBA32F:r.RGBA;r.texImage2D(r.TEXTURE_2D,0,o,1,1,0,r.RGBA,r.FLOAT,null),r.bindFramebuffer(r.FRAMEBUFFER,s),r.framebufferTexture2D(r.FRAMEBUFFER,r.COLOR_ATTACHMENT0,r.TEXTURE_2D,i,0);const a=r.checkFramebufferStatus(r.FRAMEBUFFER)===r.FRAMEBUFFER_COMPLETE;r.readPixels(0,0,1,1,r.RGBA,r.FLOAT,new Float32Array(4));const E=r.getError()===r.NO_ERROR;return t(r),a&&E}function i(n){if(2!==n)return!1;const r=e(n),s=null!=r.getExtension("WEBGL_get_buffer_sub_data_async");return t(r),s}function o(){const e={};if("undefined"==typeof window)return e;const t=c.getQueryParams(window.location.search);if(h in t){const n={};t[h].split(",").forEach(e=>{const[t,r]=e.split(":");n[t]=r}),exports.URL_PROPERTIES.forEach(t=>{t.name in n&&(console.log(`Setting feature override from URL ${t.name}: `+`${n[t.name]}`),t.type===f.NUMBER?e[t.name]=+n[t.name]:t.type===f.BOOLEAN?e[t.name]="true"===n[t.name]:console.warn(`Unknown URL param: ${t.name}.`))})}return e}function a(){let e;if("undefined"!=typeof window)e=window;else{if(void 0===u)throw new Error("Could not find a global object");e=u}return e}function E(){const e=a();return e.ENV=e.ENV||new _(o()),e.ENV}var u=(0,eval)("this");Object.defineProperty(exports,"__esModule",{value:!0});const l=require("./math/math"),c=require("./util");var f;!function(e){e[e.NUMBER=0]="NUMBER",e[e.BOOLEAN=1]="BOOLEAN"}(f=exports.Type||(exports.Type={})),exports.URL_PROPERTIES=[{name:"WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_ENABLED",type:f.BOOLEAN},{name:"WEBGL_VERSION",type:f.NUMBER},{name:"WEBGL_FLOAT_TEXTURE_ENABLED",type:f.BOOLEAN},{name:"WEBGL_GET_BUFFER_SUB_DATA_ASYNC_EXTENSION_ENABLED",type:f.BOOLEAN}];class _{constructor(e){this.features={},this.globalMath=null,this.backendRegistry={},this.prevBackendRegistry=this.backendRegistry,null!=e&&(this.features=e)}get(e){return e in this.features?this.features[e]:(this.features[e]=this.evaluateFeature(e),this.features[e])}getBestBackend(){const e=["webgl","cpu"];for(let t=0;t<e.length;++t){const n=e[t];if(n in this.backendRegistry)return this.backendRegistry[n]}throw new Error("No backend found in registry.")}evaluateFeature(e){if("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_ENABLED"===e){const e=this.get("WEBGL_VERSION");return 0!==e&&r(e)}if("WEBGL_VERSION"===e)return n(2)?2:n(1)?1:0;if("WEBGL_FLOAT_TEXTURE_ENABLED"===e)return s(this.get("WEBGL_VERSION"));if("WEBGL_GET_BUFFER_SUB_DATA_ASYNC_EXTENSION_ENABLED"===e)return i(this.get("WEBGL_VERSION"));throw new Error(`Unknown feature ${e}.`)}setFeatures(e){this.empty(),this.features=e}reset(){this.globalMath=null,this.backendRegistry=this.prevBackendRegistry,this.features=o()}setMath(e){this.globalMath=e}getBackend(e){return this.backendRegistry[e]}registerBackend(e,t){if(e in this.backendRegistry)throw new Error(`${e} backend was already registered`);try{const n=t();return this.backendRegistry[e]=n,!0}catch(e){return!1}}get math(){if(null==this.globalMath){const e=this.getBestBackend();this.globalMath=new l.NDArrayMath(e)}return this.globalMath}empty(){this.globalMath=null,this.prevBackendRegistry=this.backendRegistry,this.backendRegistry={},this.features=null}}exports.Environment=_;const h="dljsflags";exports.ENV=E();
},{"./math/math":18,"./util":24}],20:[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0});const t=require("seedrandom"),e=require("../../environment"),a=require("../../util"),r=require("../broadcast_util"),n=require("../concat_util"),o=require("../ndarray"),s=require("../types"),l=require("../types"),i=require("./../axis_util");class h{constructor(){this.data=new WeakMap,"undefined"!=typeof document&&(this.canvas=document.createElement("canvas"))}register(t,e,a){this.data.set(t,null)}write(t,e){if(null==e)throw new Error("MathBackendCPU.write(): values can not be null");this.throwIfNoData(t),this.data.set(t,e)}writePixels(t,e,a){if(null==e)throw new Error("MathBackendCPU.writePixels(): pixels can not be null");this.throwIfNoData(t);let r;if(e instanceof ImageData)r=e.data;else if(e instanceof HTMLCanvasElement)r=e.getContext("2d").getImageData(0,0,e.width,e.height).data;else{if(!(e instanceof HTMLImageElement||e instanceof HTMLVideoElement))throw new Error(`pixels is of unknown type: ${e.constructor.name}`);if(null==this.canvas)throw new Error("Can't read pixels from HTMLImageElement outside the browser.");this.canvas.width=e.width,this.canvas.height=e.height,this.canvas.getContext("2d").drawImage(e,0,0,e.width,e.height),r=this.canvas.getContext("2d").getImageData(0,0,e.width,e.height).data}let n;if(4===a)n=new Int32Array(r);else{const t=e.width*e.height;n=new Int32Array(t*a);for(let e=0;e<t;e++)for(let t=0;t<a;++t)n[e*a+t]=r[4*e+t]}this.data.set(t,n)}async read(t){return this.throwIfNoData(t),this.data.get(t)}readSync(t){return this.throwIfNoData(t),this.data.get(t)}disposeData(t){this.data.delete(t)}async time(t){const e=performance.now();return t(),performance.now()-e}throwIfNoData(t){if(!this.data.has(t))throw new Error(`No data found for NDArray with data id ${t}. `+"Use dl.ENV.math instead of constructing your own NDArrayMath. If you need to construct your own math, make sure this array is allocated after the math construction")}clone(t){return o.NDArray.make(t.shape,{values:new Float32Array(t.dataSync())})}slice1D(t,e,a){const r=t.dataSync().slice(e,e+a);return o.Array1D.new(r)}slice2D(t,e,a){const r=o.Array2D.zeros(a),[n,s]=e;for(let e=0;e<a[0];++e)for(let o=0;o<a[1];++o){const a=t.get(e+n,o+s);r.set(a,e,o)}return r}slice3D(t,e,a){const r=o.Array3D.zeros(a),[n,s,l]=e;for(let e=0;e<a[0];++e)for(let o=0;o<a[1];++o)for(let i=0;i<a[2];++i){const a=t.get(e+n,o+s,i+l);r.set(a,e,o,i)}return r}slice4D(t,e,a){const r=o.Array4D.zeros(a),[n,s,l,i]=e;for(let e=0;e<a[0];++e)for(let o=0;o<a[1];++o)for(let h=0;h<a[2];++h)for(let c=0;c<a[3];++c){const a=t.get(e+n,o+s,h+l,c+i);r.set(a,e,o,h,c)}return r}concat1D(t,e){const a=n.computeOutShape(t.shape,e.shape,0),r=o.Array1D.zeros(a),s=t.dataSync(),l=e.dataSync(),i=r.dataSync();return i.set(s,0),i.set(l,t.size),r}concat2D(t,e,a){const r=n.computeOutShape(t.shape,e.shape,a),s=o.Array2D.zeros(r);if(0===a){const a=t.dataSync(),r=e.dataSync(),n=s.dataSync();return n.set(a,0),n.set(r,t.size),s}for(let n=0;n<r[0];++n)for(let o=0;o<r[1];++o){const r=[n,o];let l;if(r[a]<t.shape[a])l=t.get(n,o);else{r[a]-=t.shape[a];const[n,o]=r;l=e.get(n,o)}s.set(l,n,o)}return s}concat3D(t,e,a){const r=n.computeOutShape(t.shape,e.shape,a),s=o.Array3D.zeros(r);if(0===a){const a=t.dataSync(),r=e.dataSync(),n=s.dataSync();return n.set(a,0),n.set(r,t.size),s}for(let n=0;n<r[0];++n)for(let o=0;o<r[1];++o)for(let l=0;l<r[2];++l){const r=[n,o,l];let i;if(r[a]<t.shape[a])i=t.get(n,o,l);else{r[a]-=t.shape[a];const[n,o,s]=r;i=e.get(n,o,s)}s.set(i,n,o,l)}return s}concat4D(t,e,a){const r=n.computeOutShape(t.shape,e.shape,a),s=o.Array4D.zeros(r);if(0===a){const a=t.dataSync(),r=e.dataSync(),n=s.dataSync();return n.set(a,0),n.set(r,t.size),s}for(let n=0;n<r[0];++n)for(let o=0;o<r[1];++o)for(let l=0;l<r[2];++l)for(let i=0;i<r[3];++i){const r=[n,o,l,i];let h;if(r[a]<t.shape[a])h=t.get(n,o,l,i);else{r[a]-=t.shape[a];const[n,o,s,l]=r;h=e.get(n,o,s,l)}s.set(h,n,o,l,i)}return s}neg(t){return this.multiply(o.Scalar.new(-1),t)}add(t,e){return this.broadcastedBinaryOp(t,e,s.upcastType(t.dtype,e.dtype),(t,e)=>t+e)}subtract(t,e){return this.broadcastedBinaryOp(t,e,s.upcastType(t.dtype,e.dtype),(t,e)=>t-e)}pow(t,e){return this.broadcastedBinaryOp(t,e,t.dtype,(t,e)=>Math.pow(t,e))}matMul(t,e,a=l.MatrixOrientation.REGULAR,r=l.MatrixOrientation.REGULAR){const n=a===l.MatrixOrientation.REGULAR?t.shape[1]:t.shape[0],s=a===l.MatrixOrientation.REGULAR?t.shape[0]:t.shape[1],i=r===l.MatrixOrientation.REGULAR?e.shape[1]:e.shape[0],h=(t,e,a)=>t.get(e,a),c=(t,e,a)=>t.get(a,e),d=a===l.MatrixOrientation.REGULAR?h:c,y=r===l.MatrixOrientation.REGULAR?h:c,p=new Float32Array(s*i);let u=0;for(let a=0;a<s;++a)for(let r=0;r<i;++r){let o=0;for(let s=0;s<n;++s)o+=d(t,a,s)*y(e,s,r);p[u++]=o}return o.Array2D.new([s,i],p)}multiply(t,e){return this.broadcastedBinaryOp(t,e,s.upcastType(t.dtype,e.dtype),(t,e)=>t*e)}divide(t,e){return this.broadcastedBinaryOp(t,e,"float32",(t,e)=>t/e)}sum(t,e){i.assertAxesAreInnerMostDims("sum",e,t.rank);const[r,n]=i.computeOutAndReduceShapes(t.shape,e),s=l.SumTypesMap[t.dtype],h=o.NDArray.zeros(r,s),c=a.sizeFromShape(n),d=h.dataSync(),y=t.dataSync();for(let t=0;t<d.length;++t){const e=t*c;let a=0;for(let t=0;t<c;++t)a+=y[e+t];d[t]=a}return h}argMin(t,e){i.assertAxesAreInnerMostDims("argMin",e,t.rank);const[r,n]=i.computeOutAndReduceShapes(t.shape,e),s=o.NDArray.zeros(r,"int32"),l=a.sizeFromShape(n),h=s.dataSync(),c=t.dataSync();for(let t=0;t<h.length;++t){const e=t*l;let r=c[e],n=0;for(let t=0;t<l;++t){const o=c[e+t];if(isNaN(o)){n=a.NAN_INT32;break}o<r&&(r=o,n=t)}h[t]=n}return s}argMax(t,e){i.assertAxesAreInnerMostDims("argMax",e,t.rank);const[r,n]=i.computeOutAndReduceShapes(t.shape,e),s=o.NDArray.zeros(r,"int32"),l=a.sizeFromShape(n),h=s.dataSync(),c=t.dataSync();for(let t=0;t<h.length;++t){const e=t*l;let r=c[e],n=0;for(let t=0;t<l;++t){const o=c[e+t];if(isNaN(o)){n=a.NAN_INT32;break}o>r&&(r=o,n=t)}h[t]=n}return s}equal(t,e){return this.broadcastedBinaryOp(t,e,"bool",(r,n)=>a.isValNaN(r,t.dtype)||a.isValNaN(n,e.dtype)?a.getNaN("bool"):r===n?1:0)}notEqual(t,e){return this.broadcastedBinaryOp(t,e,"bool",(r,n)=>a.isValNaN(r,t.dtype)||a.isValNaN(n,e.dtype)?a.getNaN("bool"):r!==n?1:0)}greater(t,e){return this.broadcastedBinaryOp(t,e,"bool",(r,n)=>a.isValNaN(r,t.dtype)||a.isValNaN(n,e.dtype)?a.getNaN("bool"):r>n?1:0)}greaterEqual(t,e){return this.broadcastedBinaryOp(t,e,"bool",(r,n)=>a.isValNaN(r,t.dtype)||a.isValNaN(n,e.dtype)?a.getNaN("bool"):r>=n?1:0)}less(t,e){return this.broadcastedBinaryOp(t,e,"bool",(r,n)=>a.isValNaN(r,t.dtype)||a.isValNaN(n,e.dtype)?a.getNaN("bool"):r<n?1:0)}lessEqual(t,e){return this.broadcastedBinaryOp(t,e,"bool",(r,n)=>a.isValNaN(r,t.dtype)||a.isValNaN(n,e.dtype)?a.getNaN("bool"):r<=n?1:0)}select(t,e,a){return this.ternaryOp(t,e,a,e.dtype,(t,e,a)=>t?e:a)}topKValues(t,e){return this.topK(t,e).values}topKIndices(t,e){return this.topK(t,e).indices}topK(t,e){const r=t.dataSync(),n=[];for(let t=0;t<r.length;t++)n.push({value:r[t],index:t});n.sort((t,e)=>e.value-t.value);const s=a.getTypedArrayFromDType(t.dtype,e),l=new Int32Array(e);for(let t=0;t<e;t++)s[t]=n[t].value,l[t]=n[t].index;return{values:o.Array1D.new(s),indices:o.Array1D.new(l)}}min(t,e){i.assertAxesAreInnerMostDims("min",e,t.rank);const[r,n]=i.computeOutAndReduceShapes(t.shape,e),s=o.NDArray.zeros(r,t.dtype),l=a.sizeFromShape(n),h=s.dataSync(),c=t.dataSync();for(let t=0;t<h.length;++t){const e=t*l;let a=c[0];for(let t=0;t<l;++t){const r=c[e+t];if(isNaN(r)){a=Number.NaN;break}r<a&&(a=r)}h[t]=a}return s}minimum(t,e){return this.broadcastedBinaryOp(t,e,t.dtype,(t,e)=>Math.min(t,e))}max(t,e){i.assertAxesAreInnerMostDims("max",e,t.rank);const[r,n]=i.computeOutAndReduceShapes(t.shape,e),s=o.NDArray.zeros(r,t.dtype),l=a.sizeFromShape(n),h=s.dataSync(),c=t.dataSync();for(let t=0;t<h.length;++t){const e=t*l;let a=c[e];for(let t=0;t<l;++t){const r=c[e+t];if(isNaN(r)){a=Number.NaN;break}r>a&&(a=r)}h[t]=a}return s}maximum(t,e){return this.broadcastedBinaryOp(t,e,t.dtype,(t,e)=>Math.max(t,e))}ceil(t){const e=t.dataSync(),a=new Float32Array(e.length);for(let t=0;t<e.length;++t)a[t]=Math.ceil(e[t]);return o.NDArray.make(t.shape,{values:a})}floor(t){const e=t.dataSync(),a=new Float32Array(e.length);for(let t=0;t<e.length;++t)a[t]=Math.floor(e[t]);return o.NDArray.make(t.shape,{values:a})}exp(t){const e=t.dataSync(),a=new Float32Array(e.length);for(let t=0;t<e.length;++t)a[t]=Math.exp(e[t]);return o.NDArray.make(t.shape,{values:a})}log(t){const e=t.dataSync(),a=new Float32Array(e.length);for(let t=0;t<e.length;++t){const r=e[t];a[t]=Math.log(r)}return o.NDArray.make(t.shape,{values:a})}sqrt(t){const e=t.dataSync(),a=new Float32Array(e.length);for(let t=0;t<e.length;++t){const r=e[t];a[t]=Math.sqrt(r)}return o.NDArray.make(t.shape,{values:a})}square(t){const e=t.dataSync(),a=new Float32Array(e.length);for(let t=0;t<e.length;++t){const r=e[t];a[t]=r*r}return o.NDArray.make(t.shape,{values:a})}relu(t){const e=o.NDArray.zeros(t.shape,t.dtype),r=e.dataSync(),n=t.dataSync();for(let o=0;o<n.length;++o){const s=n[o];a.isValNaN(s,t.dtype)?r[o]=a.getNaN(e.dtype):r[o]=Math.max(0,n[o])}return e}elu(t){const e=new Float32Array(t.size),a=t.dataSync();for(let t=0;t<a.length;++t){const r=a[t];e[t]=r>=0?r:Math.exp(r)-1}return o.NDArray.make(t.shape,{values:e})}eluDer(t){const e=new Float32Array(t.size),a=t.dataSync();for(let t=0;t<a.length;++t){const r=a[t];e[t]=r>=0?1:Math.exp(r)}return o.NDArray.make(t.shape,{values:e})}selu(t){const e=new Float32Array(t.size),a=t.dataSync();for(let t=0;t<a.length;++t){const r=a[t];e[t]=r>=0?1.0507009873554805*r:1.7580993408473768*(Math.exp(r)-1)}return o.NDArray.make(t.shape,{values:e})}leakyRelu(t,e){const a=new Float32Array(t.size),r=t.dataSync();for(let t=0;t<r.length;t++){const n=r[t];a[t]=n>=0?n:e*n}return o.NDArray.make(t.shape,{values:a})}prelu(t,e){const a=new Float32Array(t.size),r=t.dataSync(),n=e.dataSync();for(let t=0;t<r.length;t++){const e=r[t];a[t]=e>=0?e:n[t]*e}return o.NDArray.make(t.shape,{values:a})}preluDer(t,e){const a=new Float32Array(t.size),r=t.dataSync(),n=e.dataSync();for(let t=0;t<r.length;t++){const e=r[t];a[t]=e>0?1:e<0?n[t]:e}return o.NDArray.make(t.shape,{values:a})}clip(t,e,a){const r=new Float32Array(t.size),n=t.dataSync();for(let t=0;t<n.length;++t)r[t]=Math.min(a,Math.max(e,n[t]));return o.NDArray.make(t.shape,{values:r})}abs(t){const e=new Float32Array(t.size),a=t.dataSync();for(let t=0;t<a.length;++t)e[t]=Math.abs(a[t]);return o.NDArray.make(t.shape,{values:e})}int(t){const e=new Int32Array(t.size),a=t.dataSync();for(let t=0;t<a.length;++t)e[t]=a[t];return o.NDArray.make(t.shape,{values:e},"int32")}sigmoid(t){const e=new Float32Array(t.size),a=t.dataSync();for(let t=0;t<a.length;++t)e[t]=1/(1+Math.exp(-a[t]));return o.NDArray.make(t.shape,{values:e})}sin(t){const e=new Float32Array(t.size),a=t.dataSync();for(let t=0;t<a.length;++t)e[t]=Math.sin(a[t]);return o.NDArray.make(t.shape,{values:e})}cos(t){const e=new Float32Array(t.size),a=t.dataSync();for(let t=0;t<a.length;++t)e[t]=Math.cos(a[t]);return o.NDArray.make(t.shape,{values:e})}tan(t){const e=new Float32Array(t.size),a=t.dataSync();for(let t=0;t<a.length;++t)e[t]=Math.tan(a[t]);return o.NDArray.make(t.shape,{values:e})}asin(t){const e=new Float32Array(t.size),a=t.dataSync();for(let t=0;t<a.length;++t)e[t]=Math.asin(a[t]);return o.NDArray.make(t.shape,{values:e})}acos(t){const e=new Float32Array(t.size),a=t.dataSync();for(let t=0;t<a.length;++t)e[t]=Math.acos(a[t]);return o.NDArray.make(t.shape,{values:e})}atan(t){const e=new Float32Array(t.size),a=t.dataSync();for(let t=0;t<a.length;++t)e[t]=Math.atan(a[t]);return o.NDArray.make(t.shape,{values:e})}sinh(t){const e=new Float32Array(t.size),a=t.dataSync();for(let t=0;t<a.length;++t)e[t]=Math.sinh(a[t]);return o.NDArray.make(t.shape,{values:e})}cosh(t){const e=new Float32Array(t.size),a=t.dataSync();for(let t=0;t<a.length;++t)e[t]=Math.cosh(a[t]);return o.NDArray.make(t.shape,{values:e})}tanh(t){const e=new Float32Array(t.size),r=t.dataSync();for(let t=0;t<r.length;++t)e[t]=a.tanh(r[t]);return o.NDArray.make(t.shape,{values:e})}step(t,e=0){const r=new Float32Array(t.size),n=t.dataSync();for(let o=0;o<n.length;++o){const s=n[o];a.isValNaN(s,t.dtype)?r[o]=a.getNaN(t.dtype):r[o]=s>0?1:e}return o.NDArray.make(t.shape,{values:r})}conv2d(t,e,a,r){const n=r.filterHeight,s=r.filterWidth,l=r.padInfo.left,i=r.padInfo.top,h=o.Array4D.zeros(r.outShape);for(let o=0;o<r.batchSize;++o)for(let c=0;c<r.outChannels;++c)for(let d=0;d<r.outHeight;++d){const y=d*r.strideHeight-l,p=Math.max(0,y),u=Math.min(r.inHeight,n+y);for(let n=0;n<r.outWidth;++n){const l=n*r.strideWidth-i,f=Math.max(0,l),g=Math.min(r.inWidth,s+l);let m=0;for(let a=p;a<u;++a){const n=a-y;for(let s=f;s<g;++s){const i=s-l;for(let l=0;l<r.inChannels;++l){m+=t.get(o,a,s,l)*e.get(n,i,l,c)}}}const A=null!=a?a.get(c):0;h.set(m+A,o,d,n,c)}}return h}conv2dDerInput(t,e,a){const r=a.filterHeight,n=a.filterWidth,s=r-1-a.padInfo.top,l=n-1-a.padInfo.left,i=a.strideHeight,h=a.strideWidth,c=o.Array4D.zeros(a.inShape);for(let o=0;o<a.batchSize;++o)for(let d=0;d<a.inChannels;++d)for(let y=0;y<a.inHeight;++y){const p=y-l,u=Math.max(0,Math.ceil(p/i)),f=Math.min(a.outHeight,(r+p)/i);for(let l=0;l<a.inWidth;++l){const g=l-s,m=Math.max(0,Math.ceil(g/h)),A=Math.min(a.outWidth,(n+g)/h);let N=0;for(let s=u;s<f;++s){const l=s*i-p;for(let i=m;i<A;++i){const c=i*h-g;for(let h=0;h<a.outChannels;++h){N+=t.get(o,s,i,h)*e.get(r-1-l,n-1-c,d,h)}}}c.set(N,o,y,l,d)}}return c}conv2dDerFilter(t,e,a){const r=a.strideHeight,n=a.strideWidth,s=a.filterHeight,l=a.filterWidth,i=o.Array4D.zeros(a.filterShape),h=a.padInfo.left,c=a.padInfo.top;for(let o=0;o<s;++o){const s=Math.max(0,Math.ceil((c-o)/r)),d=Math.min(a.outHeight,(a.inHeight+c-o)/r);for(let y=0;y<l;++y){const l=Math.max(0,Math.ceil((h-y)/n)),p=Math.min(a.outWidth,(a.inWidth+h-y)/n);for(let u=0;u<a.inChannels;++u)for(let f=0;f<a.outChannels;++f){let g=0;for(let i=0;i<a.batchSize;++i)for(let a=s;a<d;++a){const s=o+a*r-c;for(let r=l;r<p;++r){const o=y+r*n-h;g+=t.get(i,s,o,u)*e.get(i,a,r,f)}}i.set(g,o,y,u,f)}}}return i}conv2dDerBias(t){const[e,a,r,n]=t.shape,s=new Float32Array(n);for(let o=0;o<n;++o){let n=0;for(let s=0;s<e;++s)for(let e=0;e<a;++e)for(let a=0;a<r;++a)n+=t.get(s,e,a,o);s[o]=n}return o.Array1D.new(s)}depthwiseConv2D(t,e,a){const r=a.filterHeight,n=a.filterWidth,s=a.padInfo.left,l=a.padInfo.top,i=a.outChannels/a.inChannels,h=o.Array4D.zeros(a.outShape);for(let o=0;o<a.batchSize;++o)for(let c=0;c<a.inChannels;++c)for(let d=0;d<a.outHeight;++d){const y=d*a.strideHeight-s,p=Math.max(0,y),u=Math.min(a.inHeight,r+y);for(let r=0;r<a.outWidth;++r){const s=r*a.strideWidth-l,f=Math.max(0,s),g=Math.min(a.inWidth,n+s);for(let a=0;a<i;++a){let n=0;for(let r=p;r<u;++r){const l=r-y;for(let i=f;i<g;++i){const h=i-s;n+=t.get(o,r,i,c)*e.get(l,h,c,a)}}h.set(n,o,d,r,c*i+a)}}}return h}tile(t,e){const r=new Array(t.rank);for(let a=0;a<r.length;a++)r[a]=t.shape[a]*e[a];let n;if("float32"===t.dtype)n=Float32Array;else if("int32"===t.dtype)n=Int32Array;else{if("bool"!==t.dtype)throw new Error(`Dtype ${t.dtype} not supported for tile`);n=Uint8Array}const s=new n(a.sizeFromShape(r)),l=o.NDArray.make(r,{values:s},t.dtype),i=t.dataSync();for(let e=0;e<l.size;++e){const a=l.indexToLoc(e),r=new Array(t.rank);for(let e=0;e<r.length;e++)r[e]=a[e]%t.shape[e];const n=t.locToIndex(r);s[e]=i[n]}return l}transpose(t,e){const a=new Array(t.rank);for(let r=0;r<a.length;r++)a[r]=t.shape[e[r]];const r=new Float32Array(t.size),n=t.dataSync(),s=o.NDArray.make(a,{values:r});for(let a=0;a<t.size;++a){const o=t.indexToLoc(a),l=new Array(o.length);for(let t=0;t<l.length;t++)l[t]=o[e[t]];r[s.locToIndex(l)]=n[a]}return s}pool(t,e,a){const r=e.strideHeight,n=e.strideWidth,s=e.filterHeight,l=e.filterWidth,i=o.Array4D.zeros(e.outShape),h=e.padInfo.top,c=e.padInfo.left;for(let o=0;o<e.batchSize;++o)for(let d=0;d<e.inChannels;++d)for(let y=0;y<e.outHeight;++y){const p=y*r-h,u=Math.max(0,p),f=Math.min(e.inHeight,s+p);for(let r=0;r<e.outWidth;++r){const h=r*n-c,p=Math.max(0,h),g=Math.min(e.inWidth,l+h);let m="max"===a?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,A=0;for(let e=u;e<f;++e){for(let r=p;r<g;++r){const n=t.get(o,e,r,d);if(isNaN(n)){m=NaN,A=NaN;break}"max"===a&&n>m||"min"===a&&n<m?m=n:"avg"===a&&(A+=n/(s*l))}if(isNaN(m))break}i.set("avg"===a?A:m,o,y,r,d)}}return i}maxPool(t,e){return this.pool(t,e,"max")}maxPoolPositions(t,e){const a=o.Array4D.zeros(e.outShape),r=e.strideHeight,n=e.strideWidth,s=e.filterHeight,l=e.filterWidth,i=e.padInfo.top,h=e.padInfo.left;for(let o=0;o<e.batchSize;++o)for(let c=0;c<e.inChannels;++c)for(let d=0;d<e.outHeight;++d){const y=d*r-i,p=Math.max(0,y),u=Math.min(e.inHeight,s+y);for(let r=0;r<e.outWidth;++r){const s=r*n-h,i=Math.max(0,s),f=Math.min(e.inWidth,l+s);let g=Number.NEGATIVE_INFINITY,m=-1;for(let e=p;e<u;++e){const a=e-y;for(let r=i;r<f;++r){const n=r-s,i=t.get(o,e,r,c);i>g&&(g=i,m=a*l+n)}}a.set(m,o,d,r,c)}}return a}maxPoolBackprop(t,e,a){const r=this.maxPoolPositions(e,a),n=a.strideHeight,s=a.strideWidth,l=a.filterHeight,i=a.filterWidth,h=i-1-a.padInfo.left,c=l-1-a.padInfo.top,d=o.Array4D.zeros(e.shape);for(let e=0;e<a.batchSize;++e)for(let o=0;o<a.inChannels;++o)for(let y=0;y<a.inHeight;++y)for(let p=0;p<a.inWidth;++p){const u=y-c,f=p-h;let g=0;for(let h=0;h<l;++h){const c=(u+h)/n;if(!(c<0||c>=a.outHeight||Math.floor(c)!==c))for(let n=0;n<i;++n){const d=(f+n)/s;if(d<0||d>=a.outWidth||Math.floor(d)!==d)continue;const y=l*i-1-r.get(e,c,d,o)===h*i+n?1:0;if(0===y)continue;g+=t.get(e,c,d,o)*y}}d.set(g,e,y,p,o)}return d}minPool(t,e){return this.pool(t,e,"min")}avgPool(t,e){return this.pool(t,e,"avg")}resizeBilinear3D(t,e,a){const r=o.Array3D.zeros([e[0],e[1],t.shape[2]]),n=a?[t.shape[0]-1,t.shape[1]-1,t.shape[2]]:t.shape,s=a?[r.shape[0]-1,r.shape[1]-1,r.shape[2]]:r.shape;for(let e=0;e<r.shape[0];e++)for(let a=0;a<r.shape[1];a++)for(let o=0;o<r.shape[2];o++){const l=n[0]*e/s[0],i=n[1]*a/s[1],h=Math.floor(l),c=Math.min(t.shape[0]-1,Math.ceil(l)),d=Math.floor(i),y=Math.min(t.shape[1]-1,Math.ceil(i)),p=t.get(h,d,o),u=t.get(c,d,o),f=i-d,g=p+(t.get(h,y,o)-p)*f,m=g+(u+(t.get(c,y,o)-u)*f-g)*(l-h);r.set(m,e,a,o)}return r}batchNormalization2D(t,e,a,r,n,s){const l=t.dataSync(),i=e.dataSync(),h=a.dataSync(),c=n?n.dataSync():[1],d=s?s.dataSync():[0],y=new Float32Array(l.length);for(let t=0;t<l.length;t++)y[t]=d[t%d.length]+(l[t]-i[t%i.length])*c[t%c.length]/Math.sqrt(h[t%h.length]+r);return o.Array2D.new(t.shape,y)}batchNormalization3D(t,e,a,r,n,s){const l=t.dataSync(),i=e.dataSync(),h=a.dataSync(),c=n?n.dataSync():[1],d=s?s.dataSync():[0],y=new Float32Array(l.length);for(let t=0;t<l.length;t++)y[t]=d[t%d.length]+(l[t]-i[t%i.length])*c[t%c.length]/Math.sqrt(h[t%h.length]+r);return o.Array3D.new(t.shape,y)}batchNormalization4D(t,e,a,r,n,s){const l=t.dataSync(),i=e.dataSync(),h=a.dataSync(),c=n?n.dataSync():new Float32Array([1]),d=s?s.dataSync():new Float32Array([0]),y=new Float32Array(l.length);for(let t=0;t<l.length;t++)y[t]=d[t%d.length]+(l[t]-i[t%i.length])*c[t%c.length]/Math.sqrt(h[t%h.length]+r);return o.Array4D.new(t.shape,y)}multinomial(e,a,r){const n=e.shape[0],s=e.shape[1],l=o.Array2D.zeros([n,a],"int32"),i=l.dataSync(),h=e.dataSync();for(let e=0;e<n;++e){const n=e*s,o=new Float32Array(s-1);o[0]=h[n];for(let t=1;t<o.length;++t)o[t]=o[t-1]+h[n+t];const l=t.alea(r.toString()),c=e*a;for(let t=0;t<a;++t){const e=l();i[c+t]=o.length;for(let a=0;a<o.length;a++)if(e<o[a]){i[c+t]=a;break}}}return l}oneHot(t,e,a,r){const n=new Float32Array(t.size*e);n.fill(r);for(let r=0;r<t.size;++r)n[r*e+t.get(r)]=a;return o.Array2D.new([t.size,e],n)}setDiag(t,e){const a=this.clone(t),r=e.dataSync();for(let t=0;t<r.length;++t){const e=r[t];a.set(e,t,t)}return a}broadcastedBinaryOp(t,e,a,n){const s=r.assertAndGetBroadcastShape(t.shape,e.shape),l=o.NDArray.zeros(s,a),i=l.dataSync(),h=t.dataSync(),c=e.dataSync(),d=r.getBroadcastDims(t.shape,s),y=r.getBroadcastDims(e.shape,s);for(let a=0;a<i.length;++a){const r=l.indexToLoc(a),o=r.slice(-t.rank);d.forEach(t=>o[t]=0);const s=t.locToIndex(o),p=r.slice(-e.rank);y.forEach(t=>p[t]=0);const u=e.locToIndex(p);i[a]=n(h[s],c[u])}return l}ternaryOp(t,e,r,n,s){a.assertShapesMatch(t.shape,e.shape),a.assertShapesMatch(e.shape,r.shape);const l=t.shape,i=o.NDArray.zeros(l,n),h=i.getValues(),c=t.getValues(),d=e.getValues(),y=r.getValues();for(let a=0;a<h.length;++a){const n=i.indexToLoc(a),o=t.locToIndex(n),l=e.locToIndex(n),p=r.locToIndex(n);h[a]=s(c[o],d[l],y[p])}return i}dispose(){}}exports.MathBackendCPU=h,e.ENV.registerBackend("cpu",()=>new h);
},{"seedrandom":523,"../../environment":15,"../../util":24,"../broadcast_util":27,"../concat_util":29,"../ndarray":17,"../types":19,"./../axis_util":28}],33:[function(require,module,exports) {
"use strict";function t(t){return t<=exports.PARALLELIZE_THRESHOLD?t:e(t,Math.floor(Math.sqrt(t)))}function e(t,e){for(let r=e;r<t;++r)if(t%r==0)return r;return t}Object.defineProperty(exports,"__esModule",{value:!0}),exports.PARALLELIZE_THRESHOLD=30,exports.computeOptimalWindowSize=t;
},{}],35:[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0});class t{constructor(t,n,e){this.variableNames=["A"];const i=t.windowSize,s=t.batchSize,a=t.inSize,d=Math.ceil(a/i);e||this.variableNames.push("bestIndicesA"),this.outputShape=[s,d];const o="max"===n?">":"<",c=e?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${i};\n\n        int bestIndex = 0;\n        float bestValue = getA(batch, inOffset);\n\n        for (int i = 0; i < ${i}; i++) {\n          int inIdx = ${c};\n          float candidate = getA(batch, inIdx);\n          if (isNaN(candidate)) {\n            setOutput(candidate);\n            return;\n          }\n          if (candidate ${o} bestValue) {\n            bestValue = candidate;\n            bestIndex = inIdx;\n          }\n        }\n        setOutput(float(bestIndex));\n      }\n    `}}exports.ArgMinMaxProgram=t;
},{}],34:[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0});const t=require("../../broadcast_util");class a{constructor(a,e,s,o,r,n){this.outputShape=[],this.supportsBroadcasting=!0,this.variableNames=["x","mean","variance"],t.assertAndGetBroadcastShape(a,e),t.assertAndGetBroadcastShape(a,s);let l="0.0";null!=o&&(t.assertAndGetBroadcastShape(a,o),this.variableNames.push("offset"),l="getOffsetAtOutCoords()");let i="1.0";null!=r&&(t.assertAndGetBroadcastShape(a,r),this.variableNames.push("scale"),i="getScaleAtOutCoords()"),this.outputShape=a,this.userCode=`\n      void main() {\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = ${l};\n        float scale = ${i};\n        float inv = scale / sqrt(variance + float(${n}));\n        setOutput((x - mean) * inv + offset);\n      }\n    `}}exports.BatchNormProgram=a;
},{"../../broadcast_util":27}],36:[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0});const r=require("../../broadcast_util"),n="\n  if (isNaN(a)) return a;\n  if (isNaN(b)) return b;\n";exports.ADD="return a + b;",exports.SUB="return a - b;",exports.MUL="return a * b;",exports.DIV="return a / b;",exports.POW="\n  return (round(mod(b, 2.0)) == 0 || round(mod(b, 2.0)) == 2) ?\n      pow(abs(a), b) : sign(a) * pow(abs(a), b);\n",exports.EQUAL=n+"\n  return float(a == b);\n",exports.NOT_EQUAL=n+"\n  return float(a != b);\n",exports.GREATER="\n  if (isNaN(a)) return a;\n  if (isNaN(b)) return b;\n  return float(a > b);\n",exports.GREATER_EQUAL="\n  if (isNaN(a)) return a;\n  if (isNaN(b)) return b;\n  return float(a >= b);\n",exports.LESS="\n  if (isNaN(a)) return a;\n  if (isNaN(b)) return b;\n  return float(a < b);\n",exports.LESS_EQUAL="\n  if (isNaN(a)) return a;\n  if (isNaN(b)) return b;\n  return float(a <= b);\n",exports.PRELU="\n  return (a >= 0.0) ? a : b * a;\n",exports.PRELU_DER="\n  return (a > 0.0) ? 1.0 : ((a < 0.0) ? b : a);\n",exports.MAX=n+"\n  return max(a, b);\n",exports.MIN=n+"\n  return min(a, b);\n";class t{constructor(n,t,a){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.outputShape=r.assertAndGetBroadcastShape(t,a),this.userCode=`\n      float binaryOperation(float a, float b) {\n        ${n}\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    `}}exports.BinaryOpProgram=t;
},{"../../broadcast_util":27}],37:[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0});class t{constructor(t,e,s){this.variableNames=["A"],this.outputShape=t;const u=e.toFixed(20),o=s.toFixed(20);this.userCode=`\n      void main() {\n        float value = getAAtOutCoords();\n        if (isNaN(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, ${u}, ${o}));\n      }\n    `}}exports.ClipProgram=t;
},{}],54:[function(require,module,exports) {
"use strict";function t(t,e){return[e,t]}function e(t,e){return t*e}function r(t,e){return[4*e,t]}function o(t,e){if(t%e!=0)throw new Error(`unpackedSize (${t}) must be a multiple of `+`${e}`);return t/e}function n(t,r,o){const n=e(t.length,o);if(r.length<n)throw new Error(`unpackedArray length (${r.length}) must be >= `+`${n}`);let l=0;for(let e=0;e<t.length;++e)r[l]=t[e],l+=o}function l(t){const e=new Uint8Array(4*t.length);for(let r=0;r<e.length;r+=4){const o=t[r/4];if(isNaN(o)){e[r]=exports.BYTE_NAN_VALUE,e[r+1]=exports.BYTE_NAN_VALUE,e[r+2]=exports.BYTE_NAN_VALUE,e[r+3]=exports.BYTE_NAN_VALUE;continue}const n=(o-exports.FLOAT_MIN)/A,l=g.map(t=>t*n).map(t=>Math.floor(t%1*255));e[r]=Math.floor(n),e[r+1]=l[0],e[r+2]=l[1],e[r+3]=l[2]}return e}function s(t){const e=new Float32Array(t.length/4);for(let r=0;r<t.length;r+=4){if(t[r]===exports.BYTE_NAN_VALUE&&t[r+1]===exports.BYTE_NAN_VALUE&&t[r+2]===exports.BYTE_NAN_VALUE&&t[r+3]===exports.BYTE_NAN_VALUE){e[r/4]=NaN;continue}let o=0;u.forEach((e,n)=>{o+=e*t[r+n]});const n=o*A+exports.FLOAT_MIN;e[r/4]=n}return e}function a(t,e,r){const n=o(t.length,r);if(e.length<n)throw new Error(`matrix length (${e.length}) must be >= ${n}`);let l=0;for(let o=0;o<t.length;o+=r)e[l++]=t[o]}function c(t,e,r){const o=t.length*r/4;if(e.length<o)throw new Error(`matrix length (${e.length}) must be >= ${o}`);let n=0;for(let o=0;o<t.length;o+=4)for(let l=0;l<r;l++)e[n++]=t[o+l]}function i(t,e){return[Math.ceil(e/2),Math.ceil(t/2)]}function h(t,e){const[r,o]=i(t,e);return r*o*4}function p(t,e,r,o){const n=h(e,r);if(o.length<n)throw new Error(`packedRGBA length (${o.length}) must be >= ${n}`);const[l,s]=i(e,r),a=r%2==1,c=e%2==1,p=Math.floor(r/2),x=Math.floor(e/2);{const e=a?4:0,n=r;let l=0;for(let s=0;s<x;++s){const a=2*s*r;for(let e=0;e<p;++e){const r=a+2*e;o[l]=t[r],o[l+1]=t[r+1],o[l+2]=t[r+n],o[l+3]=t[r+n+1],l+=4}l+=e}}if(a){let e=r-1,n=4*(l-1);const s=2*r,a=4*l;for(let l=0;l<x;++l)o[n]=t[e],o[n+2]=t[e+r],e+=s,n+=a}if(c){let n=(e-1)*r,a=(s-1)*l*4;for(let e=0;e<p;++e)o[a++]=t[n++],o[a++]=t[n++],a+=2}return a&&c&&(o[o.length-4]=t[t.length-1]),o}function x(t,e,r,o){const n=e*r;if(n<o.length)throw new Error(`matrix length (${o.length}) must be >= ${n}`);const l=r%2==1,s=e%2==1,a=Math.floor(r/2),c=Math.floor(e/2),[h,p]=i(e,r);{const e=l?4:0,n=r+(l?1:0);let s=0,i=0,h=r;for(let r=0;r<c;++r){for(let e=0;e<a;++e)o[i++]=t[s++],o[i++]=t[s++],o[h++]=t[s++],o[h++]=t[s++];s+=e,i+=n,h+=n}}if(l){let e=4*(h-1),n=r-1;const l=4*h,s=2*r;for(let a=0;a<c;++a)o[n]=t[e],o[n+r]=t[e+2],e+=l,n+=s}if(s){let n=(p-1)*h*4,l=(e-1)*r;for(let e=0;e<a;++e)o[l++]=t[n++],o[l++]=t[n++],n+=2}return l&&s&&(o[o.length-1]=t[t.length-4]),o}Object.defineProperty(exports,"__esModule",{value:!0});var f;!function(t){t[t.DEFAULT=0]="DEFAULT",t[t.RGBA_COLOR=1]="RGBA_COLOR"}(f=exports.TextureType||(exports.TextureType={})),exports.getUnpackedMatrixTextureShapeWidthHeight=t,exports.getUnpackedArraySizeFromMatrixSize=e,exports.getColorMatrixTextureShapeWidthHeight=r,exports.getMatrixSizeFromUnpackedArraySize=o,exports.encodeMatrixToUnpackedArray=n,exports.FLOAT_MAX=2e4,exports.FLOAT_MIN=-exports.FLOAT_MAX;const A=(exports.FLOAT_MAX-exports.FLOAT_MIN)/255,u=[1,1/255,1/65025,1/16581375],g=[1,255,65025];exports.BYTE_NAN_VALUE=0,exports.encodeFloatArray=l,exports.decodeToFloatArray=s,exports.decodeMatrixFromUnpackedArray=a,exports.decodeMatrixFromUnpackedColorRGBAArray=c,exports.getPackedMatrixTextureShapeWidthHeight=i,exports.getPackedRGBAArraySizeFromMatrixShape=h,exports.encodeMatrixToPackedRGBA=p,exports.decodeMatrixFromPackedRGBA=x;
},{}],60:[function(require,module,exports) {
"use strict";function n(n,r,a,u){const l=e(),c=t(),s=n.map(n=>`uniform sampler2D ${n.name};`).join("\n"),p=n.map(n=>o(n,r,u)).join("\n"),x=r.textureShape,v=i(r.logicalShape,x);return[L,l,c,s,v,p,a].join("\n")}function e(){return w.ENV.get("WEBGL_FLOAT_TEXTURE_ENABLED")?_:A}function t(){return w.ENV.get("WEBGL_FLOAT_TEXTURE_ENABLED")?I:O}function r(n){const e=n.shapeInfo.logicalShape;switch(e.length){case 0:return p(n);case 1:return x(n);case 2:return v(n);case 3:return d(n);case 4:return f(n);default:throw new Error(`${e.length}-D input sampling`+" is not yet supported")}}function o(n,e,t){let o=$(n);return o+=r(n),(t||T.arraysEqual(n.shapeInfo.logicalShape,e.logicalShape))&&(o+=m(n,e,t)),o}function i(n,e){switch(n.length){case 0:return a();case 1:return u(n,e);case 2:return s(n,e);case 3:return l(n,e);case 4:return c(n,e);default:throw new Error(`${n.length}-D output sampling is not yet supported`)}}function a(){return"\n    int getOutputCoords() {\n      return 0;\n    }\n  "}function u(n,e){return 1===e[0]?`\n      int getOutputCoords() {\n        return int(resultUV.x * ${e[1]}.0);\n      }\n    `:1===e[1]?`\n      int getOutputCoords() {\n        return int(resultUV.y * ${e[0]}.0);\n      }\n    `:`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${e[0]}, ${e[1]}));\n      return resTexRC.x * ${e[1]} + resTexRC.y;\n    }\n  `}function l(n,e){const t=n[1]*n[2],r=n[2];return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${e[0]}, ${e[1]}));\n      int index = resTexRC.x * ${e[1]} + resTexRC.y;\n      int r = index / ${t};\n      index -= r * ${t};\n      int c = index / ${r};\n      int d = index - c * ${r};\n      return ivec3(r, c, d);\n    }\n  `}function c(n,e){const t=n[3],r=n[2]*t,o=n[1]*r;return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${e[0]}, ${e[1]}));\n      int index = resTexRC.x * ${e[1]} + resTexRC.y;\n\n      int r = index / ${o};\n      index -= r * ${o};\n\n      int c = index / ${r};\n      index -= c * ${r};\n\n      int d = index / ${t};\n      int d2 = index - d * ${t};\n\n      return ivec4(r, c, d, d2);\n    }\n  `}function s(n,e){return T.arraysEqual(n,e)?`\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx *\n                     vec2(${e[0]}, ${e[1]}));\n      }\n    `:1===n[1]?`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${e[0]}, ${e[1]}));\n        int index = resTexRC.x * ${e[1]} + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    `:1===n[0]?`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${e[0]}, ${e[1]}));\n        int index = resTexRC.x * ${e[1]} + resTexRC.y;\n        return ivec2(0, index);\n      }\n    `:`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${e[0]}, ${e[1]}));\n      int index = resTexRC.x * ${e[1]} + resTexRC.y;\n      int r = index / ${n[1]};\n      int c = index - r * ${n[1]};\n      return ivec2(r, c);\n    }\n  `}function p(n){const e=n.name;return`\n    float ${"get"+e.charAt(0).toUpperCase()+e.slice(1)}() {\n      return sample(${e}, halfCR);\n    }\n  `}function x(n){const e=n.name,t="get"+e.charAt(0).toUpperCase()+e.slice(1);return`\n    float ${t}(int index) {\n      return ${t}Flat(index);\n    }\n  `}function v(n){const e=n.shapeInfo.logicalShape,t=n.shapeInfo.textureShape,o=n.name,i="get"+o.charAt(0).toUpperCase()+o.slice(1),a=t[0],u=t[1];if(T.arraysEqual(e,t))return`\n    float ${i}(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(${u}.0, ${a}.0);\n      return sample(${o}, uv);\n    }\n  `;const{newShape:l,keptDims:c}=T.squeezeShape(e),s=l;if(s.length<e.length){return`\n      ${r(g(n,s))}\n      float ${i}(int row, int col) {\n        return ${i}(${R(["row","col"],c)});\n      }\n    `}return 1===u?`\n    float ${i}(int row, int col) {\n      int index = row * ${e[1]} + col;\n      vec2 uv = vec2(0.5, (float(index) + 0.5) / ${a}.0);\n      return sample(${o}, uv);\n    }\n  `:1===a?`\n    float ${i}(int row, int col) {\n      int index = row * ${e[1]} + col;\n      vec2 uv = vec2((float(index) + 0.5) / ${u}.0, 0.5);\n      return sample(${o}, uv);\n    }\n  `:`\n  float ${i}(int row, int col) {\n    vec2 uv = UVfrom2D(${a}, ${u}, ${e[1]}, row, col);\n    return sample(${o}, uv);\n  }\n`}function d(n){const e=n.shapeInfo.textureShape,t=n.shapeInfo.logicalShape,o=n.name,i="get"+o.charAt(0).toUpperCase()+o.slice(1),a=e[0],u=e[1],l=t[1]*t[2],c=t[2],s=n.shapeInfo.textureType;if(s===N.TextureType.DEFAULT){const{newShape:e,keptDims:o}=T.squeezeShape(t),a=e;if(a.length<t.length){return`\n        ${r(g(n,a))}\n        float ${i}(int row, int col, int depth) {\n          return ${i}(${R(["row","col","depth"],o)});\n        }\n      `}}if(u===l){if(s===N.TextureType.DEFAULT)return`\n        float ${i}(int row, int col, int depth) {\n          int texR = row;\n          int texC = col * ${c} + depth;\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2(${u}.0, ${a}.0);\n          return sample(${o}, uv);\n        }\n      `;if(s===N.TextureType.RGBA_COLOR)return`\n        float ${i}(int row, int col, int depth) {\n          vec2 uv = (vec2(col, row) + halfCR) /\n                     vec2(${u}.0, ${a}.0);\n          return sampleUVAndDepth(${o}, uv, depth);\n        }\n      `;throw new Error(`Unknown TextureType ${s}.`)}if(u===c&&s===N.TextureType.DEFAULT)return`\n    float ${i}(int row, int col, int depth) {\n      int texR = row * ${t[1]} + col;\n      int texC = depth;\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${u}.0, ${a}.0);\n      return sample(${o}, uv);\n    }\n  `;if(s===N.TextureType.DEFAULT)return`\n      float ${i}(int row, int col, int depth) {\n        vec2 uv = UVfrom3D(\n            ${a}, ${u}, ${l}, ${c}, row, col, depth);\n        return sample(${o}, uv);\n      }\n  `;if(s===N.TextureType.RGBA_COLOR)return`\n      float ${i}(int row, int col, int depth) {\n        vec2 uv = UVfrom2D(${a}, ${u}, ${t[1]}, row, col);\n        return sampleUVAndDepth(${o}, uv, depth);\n      }\n    `;throw new Error(`Unknown TextureType ${s}.`)}function f(n){const e=n.shapeInfo.logicalShape,t=n.shapeInfo.textureShape,o=n.name,i="get"+o.charAt(0).toUpperCase()+o.slice(1),a=t[0],u=t[1],l=e[3],c=e[2]*l,s=e[1]*c,{newShape:p,keptDims:x}=T.squeezeShape(e);if(p.length<e.length){return`\n      ${r(g(n,p))}\n      float ${i}(int row, int col, int depth, int depth2) {\n        return ${i}(${R(["row","col","depth","depth2"],x)});\n      }\n    `}return u===s?`\n      float ${i}(int row, int col, int depth, int depth2) {\n        int texR = row;\n        int texC = col * ${c} + depth * ${l} + depth2;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${u}.0, ${a}.0);\n        return sample(${o}, uv);\n      }\n    `:u===l?`\n      float ${i}(int row, int col, int depth, int depth2) {\n        int texR = row * ${e[1]*e[2]} + col * ${e[2]} + depth;\n        int texC = depth2;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${u}.0, ${a}.0);\n        return sample(${o}, uv);\n      }\n    `:`\n    float ${i}(int row, int col, int depth, int depth2) {\n      vec2 uv = UVfrom4D(${a}, ${u}, ${s}, ${c},\n          ${l}, row, col, depth, depth2);\n      return sample(${o}, uv);\n    }\n  `}function $(n){const e=n.name,t=n.shapeInfo.textureShape,r="get"+e.charAt(0).toUpperCase()+e.slice(1)+"Flat",o=t[0],i=t[1];return 1===i&&1===o?`\n      float ${r}(int index) {\n        return sample(${e}, halfCR);\n      }\n    `:1===i?`\n      float ${r}(int index) {\n        vec2 uv = vec2(0.5, (float(index) + 0.5) / ${o}.0);\n        return sample(${e}, uv);\n      }\n    `:1===o?`\n      float ${r}(int index) {\n        vec2 uv = vec2((float(index) + 0.5) / ${i}.0, 0.5);\n        return sample(${e}, uv);\n      }\n    `:`\n    float ${r}(int index) {\n      vec2 uv = UVfrom1D(${o}, ${i}, index);\n      return sample(${e}, uv);\n    }\n  `}function h(n,e,t,r){const o=n.shapeInfo.logicalShape.length,i=e.logicalShape.length;let a="int";2===i?a="ivec2":3===i?a="ivec3":4===i&&(a="ivec4");const u=V.getBroadcastDims(n.shapeInfo.logicalShape,e.logicalShape),l=i-o;let c;c=0===o?"":i<2&&u.length>=1?"coords = 0;":u.map(n=>`coords[${n+l}] = 0;`).join("\n");let s="";return s=i<2&&o>0?"coords":n.shapeInfo.logicalShape.map((n,e)=>`coords[${e+l}]`).join(", "),`\n    float ${r}() {\n      ${a} coords = getOutputCoords();\n      ${c}\n      return get${t}(${s});\n    }\n  `}function m(n,e,t){const r=n.shapeInfo.textureShape,o=n.name,i=n.shapeInfo.textureType===N.TextureType.RGBA_COLOR,a=o.charAt(0).toUpperCase()+o.slice(1),u="get"+a+"AtOutCoords",l=V.getBroadcastDims(n.shapeInfo.logicalShape,e.logicalShape),c=n.shapeInfo.logicalShape.length,s=e.logicalShape.length,p=t&&(s>c||l.length>0),x=V.broadcastDimsAreOuter(l);if(p&&!x)return h(n,e,a,u);const v=e.textureShape;if(T.arraysEqual(r,v)&&!i)return`\n      float ${u}() {\n        return sample(${o}, resultUV);\n      }\n    `;const d=i?[r[0],r[1]*n.shapeInfo.logicalShape[2]]:r;let f=`return sample(${o}, uv);`,$="";i&&($=`\n      int col = texC / ${n.shapeInfo.logicalShape[2]};\n      int texD = texC - col * ${n.shapeInfo.logicalShape[2]};\n      texC = col;\n    `,f=`return sampleUVAndDepth(${o}, uv, texD);`);const m=T.sizeFromShape(d);let C="";return p&&x&&(C=`\n        int mainPart = index / ${m};\n        index -= mainPart * ${m};\n      `),`\n    float ${u}() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${v[0]}, ${v[1]}));\n      int index = resTexRC.x * ${v[1]} + resTexRC.y;\n      ${C}\n      int texR = index / ${d[1]};\n      int texC = index - texR * ${d[1]};\n\n      ${$}\n\n      vec2 uv = (vec2(texC, texR) + halfCR) /\n                 vec2(${r[1]}.0, ${r[0]}.0);\n\n      ${f}\n    }\n  `}function C(n){if(1===n)return"int";if(2===n)return"ivec2";if(3===n)return"ivec3";if(4===n)return"ivec4";throw Error(`GPU for rank ${n} is not yet supported`)}function g(n,e){const t=JSON.parse(JSON.stringify(n));return t.shapeInfo.logicalShape=e,t}function R(n,e){return e.map(e=>n[e]).join(", ")}Object.defineProperty(exports,"__esModule",{value:!0});const w=require("../../../environment"),T=require("../../../util"),V=require("../../broadcast_util"),y=require("./tex_util"),N=require("./tex_util");exports.makeShader=n;const U="\nvec2 UVfrom1D(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",D="\nvec2 UVfrom2D(int texNumR, int texNumC, int numC, int row, int col) {\n  int index = row * numC + col;\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",S="\nvec2 UVfrom3D(int texNumR, int texNumC, int stride0,\n    int stride1, int row, int col, int depth) {\n  // Explicitly use integer operations as dot() only works on floats.\n  int index = row * stride0 + col * stride1 + depth;\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",E="\nvec2 UVfrom4D(int texNumR, int texNumC, int stride0,\n    int stride1, int stride2, int row, int col, int depth,\n    int depth2) {\n  // Explicitly use integer operations as dot() only works on floats.\n  int index = row * stride0 + col * stride1 + depth * stride2 + depth2;\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",A=`\n  uniform float NaN;\n\n  const vec4 floatDeltas = vec4(\n      1.0,\n      1.0 / 255.0,\n      1.0 / (255.0 * 255.0),\n      1.0 / (255.0 * 255.0 * 255.0)\n  );\n  const float minValue = ${y.FLOAT_MIN}.0;\n  const float maxValue = ${y.FLOAT_MAX}.0;\n  const float range = (maxValue - minValue) / 255.0;\n  const vec2 dotRange = vec2(1.0, range);\n\n  float sample(sampler2D texture, vec2 uv) {\n    vec4 sampleValue = texture2D(texture, uv);\n    if (all(equal(sampleValue, vec4(${y.BYTE_NAN_VALUE})))) {\n      return NaN;\n    }\n\n    vec4 encValue = floor(sampleValue * 255.0 + 0.5);\n    float decodedValue = dot(encValue, floatDeltas);\n    return dot(vec2(minValue, decodedValue), dotRange);\n  }\n`,O=`\n  const vec4 floatPowers = vec4(\n    1.0,\n    255.0,\n    255.0 * 255.0,\n    255.0 * 255.0 * 255.0\n  );\n  const vec2 recipRange = vec2(1.0/range);\n  const vec2 recipRange255 = vec2(1.0/(maxValue - minValue));\n\n  void setOutput(float decodedValue) {\n    if (isNaN(decodedValue)) {\n      gl_FragColor = vec4(${y.BYTE_NAN_VALUE});\n      return;\n    }\n\n    float a = dot(vec2(decodedValue, -minValue), recipRange);\n    float b = fract(a) * 255.0;\n    float c = fract(b) * 255.0;\n    float d = fract(c) * 255.0;\n    gl_FragColor = floor(vec4(a, b, c, d)) / 255.0;\n\n    // TODO(dsmilkov): Version above gets better accuracy but probably slower\n    // than the version below. Benchmark to determine if the accuracy is worth\n    // the cost.\n\n    // float normValue = dot(vec2(decodedValue, -minValue), recipRange255);\n    // vec4 f = normValue * floatPowers;\n    // gl_FragColor = floor(fract(f) * 255.0) / 255.0;\n  }\n`,_="\n  float sample(sampler2D texture, vec2 uv) {\n    return texture2D(texture, uv).r;\n  }\n",I="\n  void setOutput(float val) {\n    gl_FragColor = vec4(val, 0, 0, 0);\n  }\n",L=`\n  precision highp float;\n  precision highp int;\n  varying vec2 resultUV;\n  const vec2 halfCR = vec2(0.5, 0.5);\n\n  bool isNaN(float val) {\n    float v1 = val * val;\n    float v2 = val * val;\n    return v1 == v2 ? false : true;\n  }\n\n  bool hasNaN(vec4 values) {\n    vec4 v1 = values * values;\n    vec4 v2 = values * values;\n    return any(notEqual(v1, v2));\n  }\n\n  float getNaN(vec4 values) {\n    return dot(vec4(1), values);\n  }\n\n  int round(float value) {\n    return int(floor(value + 0.5));\n  }\n\n  int imod(int x, int y) {\n    return x - y * (x / y);\n  }\n\n  const vec2 randomConst = vec2(\n    23.14069263277926, // e^pi (Gelfond's constant)\n     2.665144142690225 // 2^sqrt(2) (Gelfond–Schneider constant)\n  );\n\n  float random(float seed) {\n      return fract(cos(dot(resultUV * seed, randomConst)) * 12345.6789);\n  }\n\n  float sampleUVAndDepth(sampler2D texture, vec2 uv, int depth) {\n    float value;\n    if (depth == 0) {\n      value = texture2D(texture, uv).r;\n    } else if (depth == 1) {\n      value = texture2D(texture, uv).g;\n    } else if (depth == 2) {\n      value = texture2D(texture, uv).b;\n    } else if (depth == 3) {\n      value = texture2D(texture, uv).a;\n    }\n    return floor(value * 255.0 + 0.5);\n  }\n\n  ${U}\n  ${D}\n  ${S}\n  ${E}\n`;exports.getCoordsDataType=C;
},{"../../../environment":15,"../../../util":24,"../../broadcast_util":27,"./tex_util":54}],38:[function(require,module,exports) {
"use strict";function t(t){if(1===t)return"yR";if(2===t)return"yR, yC";if(3===t)return"yR, yC, yD";if(4===t)return"yR, yC, yD, yW";throw Error(`Concat for rank ${t} is not yet supported`)}function e(t){let e=1===t?"int yR = coords;":"int yR = coords.x;";if(t>1&&(e+="\nint yC = coords.y;"),t>2&&(e+="\nint yD = coords.z;"),t>3&&(e+="\nint yW = coords.w;"),t>4)throw Error(`Concat for rank ${t} is not yet supported`);return e}Object.defineProperty(exports,"__esModule",{value:!0});const n=require("../../concat_util"),o=require("./shader_compiler");class r{constructor(r,s,u){this.variableNames=["A","B"],this.outputShape=[];const i=["yR","yC","yD","yW"][u];this.outputShape=n.computeOutShape(r,s,u);const a=o.getCoordsDataType(r.length),y=e(r.length),c=t(r.length);this.userCode=`\n      void main() {\n        ${a} coords = getOutputCoords();\n        ${y}\n\n        float value = 0.0;\n        if (${i} < ${r[u]}) {\n          value = getA(${c});\n        } else {\n          ${i} -= ${r[u]};\n          value = getB(${c});\n        }\n\n        setOutput(value);\n      }\n    `}}exports.ConcatProgram=r;
},{"../../concat_util":29,"./shader_compiler":60}],39:[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0});class n{constructor(n){this.variableNames=["x","dy"],this.outputShape=n.filterShape;const t=n.strideHeight,o=n.strideWidth,d=n.padInfo.top,e=n.padInfo.left;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${n.batchSize}; b++) {\n          for (int yR = 0; yR < ${n.outHeight}; yR++) {\n            int xR = wR + yR * ${t} - ${d};\n\n            if (xR < 0 || xR >= ${n.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${n.outWidth}; yC++) {\n              int xC = wC + yC * ${o} - ${e};\n\n              if (xC < 0 || xC >= ${n.inWidth}) {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}exports.Conv2DDerFilterProgram=n;class t{constructor(n){this.variableNames=["dy","W"],this.outputShape=n.inShape;const t=n.filterHeight,o=n.filterWidth,d=n.strideHeight,e=n.strideWidth,i=t-1-n.padInfo.top,r=o-1-n.padInfo.left;this.userCode=`\n      const ivec2 pads = ivec2(${i}, ${r});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${t}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${d}.0;\n\n          if (dyR < 0.0 || dyR >= ${n.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${t} - 1 - wR;\n\n          for (int wC = 0; wC < ${o}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${e}.0;\n\n            if (dyC < 0.0 || dyC >= ${n.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${o} - 1 - wC;\n\n            for (int d2 = 0; d2 < ${n.outChannels}; d2++) {\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, d2);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}exports.Conv2DDerInputProgram=t;class o{constructor(n){this.variableNames=["dy"];const[t,o,d,e]=n;this.outputShape=[e],this.userCode=`\n      void main() {\n        int d2 = getOutputCoords();\n\n        float derBias = 0.0;\n        for (int b = 0; b < ${t}; b++) {\n          for (int yR = 0; yR < ${o}; yR++) {\n            for (int yC = 0; yC < ${d}; yC++) {\n              derBias += getDy(b, yR, yC, d2);\n            }\n          }\n        }\n        setOutput(derBias);\n      }\n    `}}exports.Conv2DDerBiasProgram=o;
},{}],40:[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0});class n{constructor(n,e){this.variableNames=["x","W"],e&&this.variableNames.push("bias"),this.outputShape=n.outShape;const t=e?"dotProd += getBias(d2);":"",d=n.padInfo.top,o=n.padInfo.left,s=n.strideHeight,i=n.strideWidth,a=n.filterHeight,r=n.filterWidth,C=4*Math.floor(n.inChannels/4),x=n.inChannels%4;this.userCode=`\n      const ivec2 strides = ivec2(${s}, ${i});\n      const ivec2 pads = ivec2(${d}, ${o});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d2 = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${a}; wR++) {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= ${n.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${r}; wC++) {\n            int xC = xCCorner + wC;\n\n            if (xC < 0 || xC >= ${n.inWidth}) {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < ${C}; d1 += 4) {\n              vec4 xValues = vec4(\n                getX(batch, xR, xC, d1),\n                getX(batch, xR, xC, d1 + 1),\n                getX(batch, xR, xC, d1 + 2),\n                getX(batch, xR, xC, d1 + 3)\n              );\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              dotProd += dot(xValues, wValues);\n            }\n\n            if (${1===x}) {\n              dotProd +=\n                getX(batch, xR, xC, ${C}) *\n                getW(wR, wC, ${C}, d2);\n            } else if (${2===x}) {\n              vec2 xValues = vec2(\n                getX(batch, xR, xC, ${C}),\n                getX(batch, xR, xC, ${C} + 1)\n              );\n              vec2 wValues = vec2(\n                getW(wR, wC, ${C}, d2),\n                getW(wR, wC, ${C} + 1, d2)\n              );\n              dotProd += dot(xValues, wValues);\n            } else if (${3===x}) {\n              vec3 xValues = vec3(\n                getX(batch, xR, xC, ${C}),\n                getX(batch, xR, xC, ${C} + 1),\n                getX(batch, xR, xC, ${C} + 2)\n              );\n              vec3 wValues = vec3(\n                getW(wR, wC, ${C}, d2),\n                getW(wR, wC, ${C} + 1, d2),\n                getW(wR, wC, ${C} + 2, d2)\n              );\n              dotProd += dot(xValues, wValues);\n            }\n          }\n        }\n        ${t}\n        setOutput(dotProd);\n      }\n    `}}exports.Conv2DProgram=n;
},{}],41:[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0});class n{constructor(n){this.variableNames=["x","W"],this.outputShape=n.outShape;const t=n.inHeight,e=n.inWidth,o=n.padInfo.top,i=n.padInfo.left,r=n.strideHeight,d=n.strideWidth,s=n.filterHeight,a=n.filterWidth,C=n.outChannels/n.inChannels;this.userCode=`\n      const ivec2 strides = ivec2(${r}, ${d});\n      const ivec2 pads = ivec2(${o}, ${i});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${C};\n        int q = d2 - d1 * ${C};\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TODO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < ${s}; wR++) {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= ${t}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${a}; wC++) {\n            int xC = xCCorner + wC;\n\n            if (xC < 0 || xC >= ${e}) {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}exports.DepthwiseConv2DProgram=n;
},{}],42:[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0});class t{constructor(t,e){this.variableNames=["source"],this.outputShape=null,this.userCode=`\n      uniform ivec2 sourceStart;\n      uniform ivec2 destStart;\n\n      void main() {\n        ivec2 destCoords = getOutputCoords() - destStart;\n        int index = destCoords.x * ${e} + destCoords.y;\n        int r = index / ${t};\n        ivec2 sourceCoords = sourceStart + ivec2(r, index - r * ${t});\n        setOutput(getSource(sourceCoords.x, sourceCoords.y));\n      }\n    `}getCustomSetupFunc(t,e,o){return(r,s)=>{r.setOutputMatrixWriteRegion(e[0],o[0],e[1],o[1]);const n=r.getUniformLocation(s,"sourceStart");r.gl.uniform2i(n,t[0],t[1]);const i=r.getUniformLocation(s,"destStart");r.gl.uniform2i(i,e[0],e[1])}}}exports.Copy2DProgram=t;
},{}],59:[function(require,module,exports) {
"use strict";function e(e){const t=document.createElement("canvas");return t.width=1,t.height=1,r(t,e)}function r(e,r){let t;const n=B.ENV.get("WEBGL_VERSION");if(2===n?t=e.getContext("webgl2",r):1===n&&(t=e.getContext("webgl",r)||e.getContext("experimental-webgl",r)),0===n||null==t)throw new Error("This browser does not support WebGL.");return t}function t(e,r){const t=r();return o(e),t}function n(e){D=e}function o(e){if(D){const r=e.getError();if(r!==e.NO_ERROR)throw new Error("WebGL Error: "+a(e,r))}}function a(e,r){switch(r){case e.NO_ERROR:return"NO_ERROR";case e.INVALID_ENUM:return"INVALID_ENUM";case e.INVALID_VALUE:return"INVALID_VALUE";case e.INVALID_OPERATION:return"INVALID_OPERATION";case e.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case e.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case e.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${r}`}}function i(e,r){return N(e,()=>e.getExtension(r),'Extension "'+r+'" not supported on this browser.')}function E(e,r){const n=N(e,()=>e.createShader(e.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(t(e,()=>e.shaderSource(n,r)),t(e,()=>e.compileShader(n)),!1===e.getShaderParameter(n,e.COMPILE_STATUS))throw console.log(e.getShaderInfoLog(n)),new Error("Failed to compile vertex shader.");return n}function u(e,r){const n=N(e,()=>e.createShader(e.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(t(e,()=>e.shaderSource(n,r)),t(e,()=>e.compileShader(n)),!1===e.getShaderParameter(n,e.COMPILE_STATUS))throw c(r,e.getShaderInfoLog(n)),new Error("Failed to compile fragment shader.");return n}function c(e,r){const t=G.exec(r);if(null==t)return console.log(`Couldn't parse line number in error: ${r}`),void console.log(e);const n=+t[1],o=e.split("\n"),a=o.length.toString().length+2,i=o.map((e,r)=>C.rightPad((r+1).toString(),a)+e);let E=0;for(let e=0;e<i.length;e++)E=Math.max(i[e].length,E);const u=i.slice(0,n-1),c=i.slice(n-1,n),s=i.slice(n);console.log(u.join("\n")),console.log(r.split("\n")[0]),console.log(`%c ${C.rightPad(c[0],E)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(s.join("\n"))}function s(e){return N(e,()=>e.createProgram(),"Unable to create WebGLProgram.")}function f(e,r){if(t(e,()=>e.linkProgram(r)),!1===e.getProgramParameter(r,e.LINK_STATUS))throw console.log(e.getProgramInfoLog(r)),new Error("Failed to link vertex and fragment shaders.")}function T(e,r){if(t(e,()=>e.validateProgram(r)),!1===e.getProgramParameter(r,e.VALIDATE_STATUS))throw console.log(e.getProgramInfoLog(r)),new Error("Shader program validation failed.")}function l(e,r){const n=N(e,()=>e.createBuffer(),"Unable to create WebGLBuffer");return t(e,()=>e.bindBuffer(e.ARRAY_BUFFER,n)),t(e,()=>e.bufferData(e.ARRAY_BUFFER,r,e.STATIC_DRAW)),n}function R(e,r){const n=N(e,()=>e.createBuffer(),"Unable to create WebGLBuffer");return t(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,n)),t(e,()=>e.bufferData(e.ELEMENT_ARRAY_BUFFER,r,e.STATIC_DRAW)),n}function g(e){return null!=w?w:w=t(e,()=>e.getParameter(e.MAX_TEXTURE_SIZE))}function F(){return B.ENV.get("WEBGL_FLOAT_TEXTURE_ENABLED")&&2===B.ENV.get("WEBGL_VERSION")?1:4}function x(e){return N(e,()=>e.createTexture(),"Unable to create WebGLTexture.")}function A(e,r,t){const n=g(e);if(r<=0||t<=0){const e=`[${r}x${t}]`;throw new Error("Requested texture size "+e+" is invalid.")}if(r>n||t>n){const e=`[${r}x${t}]`,o=`[${n}x${n}]`;throw new Error("Requested texture size "+e+" greater than WebGL maximum on this browser / GPU "+o+".")}}function b(e){return N(e,()=>e.createFramebuffer(),"Unable to create WebGLFramebuffer.")}function d(e,r,n,o,a,i,E,u){let c=-1;-1!==(c=null!=u&&n in u?u[n]:e.getAttribLocation(r,n))&&(t(e,()=>e.bindBuffer(e.ARRAY_BUFFER,o)),t(e,()=>e.vertexAttribPointer(c,a,e.FLOAT,!1,i,E)),t(e,()=>e.enableVertexAttribArray(c)))}function _(e,r,n){O(e,n),t(e,()=>e.activeTexture(e.TEXTURE0+n)),t(e,()=>e.bindTexture(e.TEXTURE_2D,r))}function h(e,r){O(e,r),t(e,()=>e.activeTexture(e.TEXTURE0+r)),t(e,()=>e.bindTexture(e.TEXTURE_2D,null))}function m(e,r,t){return N(e,()=>e.getUniformLocation(r,t),'uniform "'+t+'" not present in program.')}function U(e,r,n,o,a){t(e,()=>_(e,n,a)),t(e,()=>e.uniform1i(o,a))}function L(e){t(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,null)),t(e,()=>e.viewport(0,0,e.canvas.width,e.canvas.height)),t(e,()=>e.scissor(0,0,e.canvas.width,e.canvas.height))}function S(e,r,n){t(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,n)),t(e,()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,r,0))}function p(e,r){t(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,r)),t(e,()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,null,0))}function M(e){const r=e.checkFramebufferStatus(e.FRAMEBUFFER);if(r!==e.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+I(e,r))}function I(e,r){switch(r){case e.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case e.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${r}`}}function N(e,r,n){const o=t(e,()=>r());if(null==o)throw new Error(n);return o}function O(e,r){const t=e.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,n=r+e.TEXTURE0;if(n<e.TEXTURE0||n>t){const e=`[gl.TEXTURE0, gl.TEXTURE${t}]`;throw new Error(`textureUnit must be in ${e}.`)}}function P(e,r){if(2!==r.length){r=C.squeezeShape(r).newShape}const t=g(e),n=C.sizeFromShape(r);return r.length<=1&&n<=t?[n,1]:2===r.length&&r[0]<=t&&r[1]<=t?r:3===r.length&&r[0]<=t&&r[1]*r[2]<=t?[r[0],r[1]*r[2]]:4===r.length&&r[0]<=t&&r[1]*r[2]*r[3]<=t?[r[0],r[1]*r[2]*r[3]]:C.sizeToSquarishShape(n)}Object.defineProperty(exports,"__esModule",{value:!0});let w=null;const B=require("../../../environment"),C=require("../../../util");exports.createWebGLRenderingContext=e,exports.createWebGLRenderingContextFromCanvas=r,exports.callAndCheck=t;let D=!1;exports.enableDebugWebGLErrorChecking=n,exports.checkWebGLError=o,exports.getWebGLErrorMessage=a,exports.getExtensionOrThrow=i,exports.createVertexShader=E,exports.createFragmentShader=u;const G=/ERROR: [0-9]+:([0-9]+):/g;exports.createProgram=s,exports.linkProgram=f,exports.validateProgram=T,exports.createStaticVertexBuffer=l,exports.createStaticIndexBuffer=R,exports.queryMaxTextureSize=g,exports.getChannelsPerTexture=F,exports.createTexture=x,exports.validateTextureSize=A,exports.createFramebuffer=b,exports.bindVertexBufferToProgramAttribute=d,exports.bindTextureUnit=_,exports.unbindTextureUnit=h,exports.getProgramUniformLocationOrThrow=m,exports.bindTextureToProgramUniformSampler=U,exports.bindCanvasToFramebuffer=L,exports.bindColorTextureToFramebuffer=S,exports.unbindColorTextureFromFramebuffer=p,exports.validateFramebuffer=M,exports.getFramebufferErrorMessage=I,exports.getTextureShapeFromLogicalShape=P;
},{"../../../environment":15,"../../../util":24}],45:[function(require,module,exports) {
"use strict";function e(){return{failIfMajorPerformanceCaveat:!0,alpha:!1,antialias:!1,depth:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,stencil:!1}}function t(t){const r=e();let a;return a=null!=t?g.createWebGLRenderingContextFromCanvas(t,r):g.createWebGLRenderingContext(r),g.callAndCheck(a,()=>a.disable(a.DEPTH_TEST)),g.callAndCheck(a,()=>a.disable(a.STENCIL_TEST)),g.callAndCheck(a,()=>a.disable(a.BLEND)),g.callAndCheck(a,()=>a.disable(a.DITHER)),g.callAndCheck(a,()=>a.disable(a.POLYGON_OFFSET_FILL)),g.callAndCheck(a,()=>a.disable(a.SAMPLE_COVERAGE)),g.callAndCheck(a,()=>a.enable(a.SCISSOR_TEST)),g.callAndCheck(a,()=>a.enable(a.CULL_FACE)),g.callAndCheck(a,()=>a.cullFace(a.BACK)),a}function r(e){return g.createVertexShader(e,"\n    precision highp float;\n    attribute vec3 clipSpacePos;\n    attribute vec2 uv;\n    varying vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }")}function a(e){const t=new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]);return g.createStaticVertexBuffer(e,t)}function n(e){const t=new Uint16Array([0,1,2,2,1,3]);return g.createStaticIndexBuffer(e,t)}function c(e,t){return F.ENV.get("WEBGL_FLOAT_TEXTURE_ENABLED")&&2===F.ENV.get("WEBGL_VERSION")?4===t?e.RGBA32F:e.R32F:e.RGBA}function i(e,t){return F.ENV.get("WEBGL_FLOAT_TEXTURE_ENABLED")&&2===F.ENV.get("WEBGL_VERSION")?4===t?e.RGBA:e.RED:e.RGBA}function o(e){return F.ENV.get("WEBGL_FLOAT_TEXTURE_ENABLED")?e.FLOAT:e.UNSIGNED_BYTE}function l(e,t,r,a){g.validateTextureSize(e,t,r);const n=g.createTexture(e),l=e.TEXTURE_2D,u=c(e,a),d=i(e,a);return g.callAndCheck(e,()=>e.bindTexture(l,n)),g.callAndCheck(e,()=>e.texParameteri(l,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE)),g.callAndCheck(e,()=>e.texParameteri(l,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE)),g.callAndCheck(e,()=>e.texParameteri(l,e.TEXTURE_MIN_FILTER,e.NEAREST)),g.callAndCheck(e,()=>e.texParameteri(l,e.TEXTURE_MAG_FILTER,e.NEAREST)),g.callAndCheck(e,()=>e.texImage2D(l,0,u,t,r,0,d,o(e),null)),g.callAndCheck(e,()=>e.bindTexture(e.TEXTURE_2D,null)),n}function u(e,t,r){const[a,n]=k.getUnpackedMatrixTextureShapeWidthHeight(t,r);return l(e,a,n,1)}function d(e,t,r){const[a,n]=k.getColorMatrixTextureShapeWidthHeight(t,r);return l(e,a,n,4)}function A(e,t,r){const[a,n]=k.getPackedMatrixTextureShapeWidthHeight(t,r);return l(e,a,n,4)}function E(e,t,r,a){g.callAndCheck(e,()=>e.bindBuffer(e.ARRAY_BUFFER,r)),g.bindVertexBufferToProgramAttribute(e,t,"clipSpacePos",r,3,20,0,a),g.bindVertexBufferToProgramAttribute(e,t,"uv",r,2,20,12,a)}function T(e,t,r){g.callAndCheck(e,()=>e.bindTexture(e.TEXTURE_2D,t)),g.callAndCheck(e,()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,e.RGBA,e.UNSIGNED_BYTE,r)),g.callAndCheck(e,()=>e.bindTexture(e.TEXTURE_2D,null))}function x(e,t,r,a,n,c){const l=i(e,c);g.validateTextureSize(e,r,a),g.callAndCheck(e,()=>e.bindTexture(e.TEXTURE_2D,t)),g.callAndCheck(e,()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,r,a,l,o(e),n)),g.callAndCheck(e,()=>e.bindTexture(e.TEXTURE_2D,null))}function s(e,t,r,a,n,c){const[i,o]=k.getUnpackedMatrixTextureShapeWidthHeight(r,a);let l;if(F.ENV.get("WEBGL_FLOAT_TEXTURE_ENABLED")){const e=1===c?g.getChannelsPerTexture():c;1===e?l=n:(l=new Float32Array(k.getUnpackedArraySizeFromMatrixSize(n.length,e)),k.encodeMatrixToUnpackedArray(n,l,e))}else l=k.encodeFloatArray(n);x(e,t,i,o,l,c)}function h(e,t,r,a,n){const[c,i]=k.getPackedMatrixTextureShapeWidthHeight(r,a),o=new Float32Array(k.getPackedRGBAArraySizeFromMatrixShape(r,a));k.encodeMatrixToPackedRGBA(n,r,a,o);x(e,t,c,i,o,4)}function _(e,t,r){let a;return a=F.ENV.get("WEBGL_FLOAT_TEXTURE_ENABLED")?new Float32Array(k.getUnpackedArraySizeFromMatrixSize(e*t,r)):new Uint8Array(e*t*r)}function f(e,t,r,a){if(F.ENV.get("WEBGL_FLOAT_TEXTURE_ENABLED")){const n=new Float32Array(t*r);return k.decodeMatrixFromUnpackedArray(e,n,a),n}return k.decodeToFloatArray(e)}async function R(e,t,r,a){const n=e,c=_(r,a,4),i=c instanceof Float32Array?4*c.length:c,l=e.createBuffer();return g.callAndCheck(e,()=>e.bindBuffer(n.PIXEL_PACK_BUFFER,l)),g.callAndCheck(e,()=>e.bufferData(n.PIXEL_PACK_BUFFER,i,e.STATIC_DRAW)),g.callAndCheck(e,()=>n.readPixels(0,0,a,r,e.RGBA,o(e),0)),await t.getBufferSubDataAsync(n.PIXEL_PACK_BUFFER,0,c),f(c,r,a,4)}function p(e,t,r){const[a,n]=k.getUnpackedMatrixTextureShapeWidthHeight(t,r),c=_(t,r,4);return g.callAndCheck(e,()=>e.readPixels(0,0,a,n,e.RGBA,o(e),c)),f(c,t,r,4)}function C(e,t,r,a){const n=t*r*4,c=new Uint8Array(n);g.callAndCheck(e,()=>e.readPixels(0,0,r,t,e.RGBA,e.UNSIGNED_BYTE,c));const i=new Float32Array(n);for(let e=0;e<c.length;e++)i[e]=c[e];const o=new Float32Array(t*r*a);return k.decodeMatrixFromUnpackedColorRGBAArray(i,o,a),o}function B(e,t,r){const[a,n]=k.getPackedMatrixTextureShapeWidthHeight(t,r),c=new Float32Array(k.getPackedRGBAArraySizeFromMatrixShape(t,r));g.callAndCheck(e,()=>e.readPixels(0,0,a,n,e.RGBA,o(e),c));const i=new Float32Array(t*r);return k.decodeMatrixFromPackedRGBA(c,t,r,i)}Object.defineProperty(exports,"__esModule",{value:!0});const F=require("../../../environment"),k=require("./tex_util"),g=require("./webgl_util");exports.getWebGLContextAttributes=e,exports.createWebGLContext=t,exports.createVertexShader=r,exports.createVertexBuffer=a,exports.createIndexBuffer=n,exports.createMatrixTexture=u,exports.createColorMatrixTexture=d,exports.createPackedMatrixTexture=A,exports.bindVertexProgramAttributeStreams=E,exports.uploadPixelDataToTexture=T,exports.uploadMatrixToTexture=s,exports.uploadMatrixToPackedTexture=h,exports.downloadMatrixFromOutputTextureAsync=R,exports.downloadMatrixFromOutputTexture=p,exports.downloadMatrixFromRGBAColorTexture=C,exports.downloadMatrixFromPackedOutputTexture=B;
},{"../../../environment":15,"./tex_util":54,"./webgl_util":59}],43:[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0});const t=require("../../../environment"),e=require("../../../util"),r=require("./gpgpu_util"),i=require("./tex_util"),o=require("./webgl_util");class s{constructor(e){this.outputTexture=null,this.program=null,this.disposed=!1,this.autoDebugValidate=!1,this.gl=null!=e?e:r.createWebGLContext(),1===t.ENV.get("WEBGL_VERSION")?(this.textureFloatExtension=o.getExtensionOrThrow(this.gl,"OES_texture_float"),this.colorBufferFloatExtension=this.gl.getExtension("WEBGL_color_buffer_float")):this.colorBufferFloatExtension=o.getExtensionOrThrow(this.gl,"EXT_color_buffer_float"),this.loseContextExtension=o.getExtensionOrThrow(this.gl,"WEBGL_lose_context"),t.ENV.get("WEBGL_GET_BUFFER_SUB_DATA_ASYNC_EXTENSION_ENABLED")&&(this.getBufferSubDataAsyncExtension=this.gl.getExtension("WEBGL_get_buffer_sub_data_async")),this.vertexBuffer=r.createVertexBuffer(this.gl),this.indexBuffer=r.createIndexBuffer(this.gl),this.framebuffer=o.createFramebuffer(this.gl)}dispose(){this.throwIfDisposed(),null!=this.program&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),null!=this.outputTexture&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const t=this.gl;o.callAndCheck(t,()=>t.finish()),o.callAndCheck(t,()=>t.bindFramebuffer(t.FRAMEBUFFER,null)),o.callAndCheck(t,()=>t.deleteFramebuffer(this.framebuffer)),o.callAndCheck(t,()=>t.bindBuffer(t.ARRAY_BUFFER,null)),o.callAndCheck(t,()=>t.deleteBuffer(this.vertexBuffer)),o.callAndCheck(t,()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,null)),o.callAndCheck(t,()=>t.deleteBuffer(this.indexBuffer)),this.loseContextExtension.loseContext(),this.disposed=!0}enableAutomaticDebugValidation(t){this.autoDebugValidate=t,o.enableDebugWebGLErrorChecking(t)}createMatrixTexture(t,e){return this.throwIfDisposed(),r.createMatrixTexture(this.gl,t,e)}uploadPixelDataToTexture(t,e){this.throwIfDisposed(),r.uploadPixelDataToTexture(this.gl,t,e)}createPackedMatrixTexture(t,e){return this.throwIfDisposed(),r.createPackedMatrixTexture(this.gl,t,e)}deleteMatrixTexture(t){this.throwIfDisposed(),this.outputTexture===t&&(o.unbindColorTextureFromFramebuffer(this.gl,this.framebuffer),this.outputTexture=null),o.callAndCheck(this.gl,()=>this.gl.deleteTexture(t))}uploadMatrixToTexture(t,e,i,o){this.throwIfDisposed();return r.uploadMatrixToTexture(this.gl,t,e,i,o,1)}uploadMatrixToPackedTexture(t,e,i,o){return this.throwIfDisposed(),r.uploadMatrixToPackedTexture(this.gl,t,e,i,o)}downloadMatrixFromTexture(t,e,i){return this.downloadMatrixDriver(t,()=>r.downloadMatrixFromOutputTexture(this.gl,e,i))}async downloadMatrixFromTextureAsync(t,e,i){if(null==this.getBufferSubDataAsyncExtension)throw new Error("Cannot download matrix from output texture asynchronously, WEBGL_get_buffer_sub_data_async is not enabled.");return this.downloadMatrixDriverAsync(t,()=>r.downloadMatrixFromOutputTextureAsync(this.gl,this.getBufferSubDataAsyncExtension,e,i))}downloadMatrixFromRGBAColorTexture(t,e,i,o){return this.downloadMatrixDriver(t,()=>r.downloadMatrixFromRGBAColorTexture(this.gl,e,i,o))}downloadMatrixFromPackedTexture(t,e,i){return this.downloadMatrixDriver(t,()=>r.downloadMatrixFromPackedOutputTexture(this.gl,e,i))}createProgram(t){this.throwIfDisposed();const e=this.gl,i=o.createFragmentShader(e,t),s=r.createVertexShader(e),a=o.createProgram(e);return o.callAndCheck(e,()=>e.attachShader(a,s)),o.callAndCheck(e,()=>e.attachShader(a,i)),o.linkProgram(e,a),this.autoDebugValidate&&o.validateProgram(e,a),a}deleteProgram(t){this.throwIfDisposed(),t===this.program&&(this.program=null),null!=t&&o.callAndCheck(this.gl,()=>this.gl.deleteProgram(t))}setProgram(t){this.throwIfDisposed(),this.program=t,null!=this.program&&this.autoDebugValidate&&o.validateProgram(this.gl,this.program),o.callAndCheck(this.gl,()=>this.gl.useProgram(t))}getUniformLocation(t,e){return this.throwIfDisposed(),o.getProgramUniformLocationOrThrow(this.gl,t,e)}getAttributeLocation(t,e){return this.throwIfDisposed(),o.callAndCheck(this.gl,()=>this.gl.getAttribLocation(t,e))}getUniformLocationNoThrow(t,e){return this.throwIfDisposed(),this.gl.getUniformLocation(t,e)}setInputMatrixTexture(t,e,r){this.throwIfDisposed(),this.throwIfNoProgram(),o.bindTextureToProgramUniformSampler(this.gl,this.program,t,e,r)}setOutputMatrixTexture(t,e,r){this.setOutputMatrixTextureDriver(t,r,e)}setOutputPackedMatrixTexture(t,e,r){this.throwIfDisposed();const[o,s]=i.getPackedMatrixTextureShapeWidthHeight(e,r);this.setOutputMatrixTextureDriver(t,o,s)}setOutputMatrixWriteRegion(t,e,r,i){this.setOutputMatrixWriteRegionDriver(r,t,i,e)}setOutputPackedMatrixWriteRegion(t,e,r,i){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){null!=this.program&&o.validateProgram(this.gl,this.program),o.validateFramebuffer(this.gl)}executeProgram(t){this.throwIfDisposed(),this.throwIfNoProgram();const e=this.gl;r.bindVertexProgramAttributeStreams(e,this.program,this.vertexBuffer,t),this.autoDebugValidate&&this.debugValidate(),o.callAndCheck(e,()=>e.drawElements(e.TRIANGLES,6,e.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),o.callAndCheck(this.gl,()=>this.gl.finish())}runQuery(e){return 2===t.ENV.get("WEBGL_VERSION")?this.runQueryWebGL2(e):this.runQueryWebGL1(e)}runQueryWebGL2(t){const r=o.getExtensionOrThrow(this.gl,"EXT_disjoint_timer_query_webgl2"),i=this.gl.createQuery();return this.gl.beginQuery(r.TIME_ELAPSED_EXT,i),t(),this.gl.endQuery(r.TIME_ELAPSED_EXT),new Promise((t,o)=>{e.repeatedTry(()=>{const t=this.gl.getQueryParameter(i,this.gl.QUERY_RESULT_AVAILABLE),e=this.gl.getParameter(r.GPU_DISJOINT_EXT);return t&&!e}).then(()=>{const e=this.gl.getQueryParameter(i,this.gl.QUERY_RESULT);t(e/1e6)}).catch(()=>{console.warn("Disjoint query timer never available."),t(-1)})})}runQueryWebGL1(t){const r=o.getExtensionOrThrow(this.gl,"EXT_disjoint_timer_query"),i=r.createQueryEXT();return r.beginQueryEXT(r.TIME_ELAPSED_EXT,i),t(),r.endQueryEXT(r.TIME_ELAPSED_EXT),new Promise((t,o)=>{e.repeatedTry(()=>{const t=r.getQueryObjectEXT(i,r.QUERY_RESULT_AVAILABLE_EXT),e=this.gl.getParameter(r.GPU_DISJOINT_EXT);return t&&!e}).then(()=>{const e=r.getQueryObjectEXT(i,r.QUERY_RESULT_EXT);t(e/1e6)}).catch(()=>{console.warn("Disjoint query timer never available."),t(-1)})})}downloadMatrixDriverSetup(t){this.throwIfDisposed(),o.bindColorTextureToFramebuffer(this.gl,t,this.framebuffer),this.autoDebugValidate&&o.validateFramebuffer(this.gl)}downloadMatrixDriverTeardown(){null!=this.outputTexture?(o.bindColorTextureToFramebuffer(this.gl,this.outputTexture,this.framebuffer),this.autoDebugValidate&&o.validateFramebuffer(this.gl)):o.unbindColorTextureFromFramebuffer(this.gl,this.framebuffer)}downloadMatrixDriver(t,e){this.downloadMatrixDriverSetup(t);const r=e();return this.downloadMatrixDriverTeardown(),r}async downloadMatrixDriverAsync(t,e){this.downloadMatrixDriverSetup(t);const r=await e();return this.downloadMatrixDriverTeardown(),r}setOutputMatrixTextureDriver(t,e,r){this.throwIfDisposed();const i=this.gl;o.bindColorTextureToFramebuffer(i,t,this.framebuffer),this.autoDebugValidate&&o.validateFramebuffer(i),this.outputTexture=t,o.callAndCheck(i,()=>i.viewport(0,0,e,r)),o.callAndCheck(i,()=>i.scissor(0,0,e,r))}setOutputMatrixWriteRegionDriver(t,e,r,i){this.throwIfDisposed(),o.callAndCheck(this.gl,()=>this.gl.scissor(t,e,r,i))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(null==this.program)throw new Error("No GPU program is currently set.")}}exports.GPGPUContext=s;
},{"../../../environment":15,"../../../util":24,"./gpgpu_util":45,"./tex_util":54,"./webgl_util":59}],44:[function(require,module,exports) {
"use strict";function e(){return!n.ENV.get("WEBGL_FLOAT_TEXTURE_ENABLED")}function t(t,a,r,o){const n=a.userCode,u=r.map((e,t)=>{const r={logicalShape:e.array.shape,textureShape:e.texData.textureShape,textureType:e.texData.textureType};return{name:a.variableNames[t],shapeInfo:r}}),c=u.map(e=>e.shapeInfo),h={logicalShape:o.array.shape,textureShape:o.texData.textureShape,textureType:o.texData.textureType},m=s.makeShader(u,h,n,!0===a.supportsBroadcasting),x=t.createProgram(m),g={};for(let e=0;e<a.variableNames.length;e++){const r=a.variableNames[e];g[r]=t.getUniformLocation(x,r)}const l={};return i.forEach(e=>{l[e]=t.getAttributeLocation(x,e)}),e()&&(g[p]=t.getUniformLocation(x,p)),{webGLProgram:x,program:a,uniformLocations:g,attributeLocations:l,gpgpu:t,source:m,inShapeInfos:c,outShapeInfo:h}}function a(e,t){if(e.length!==t.length)throw Error(`Binary was compiled with ${e.length} inputs, but `+`was executed with ${t.length} inputs`);e.forEach((e,a)=>{const r=e.logicalShape,o=e.textureShape,n=t[a].array.shape,s=t[a].texData.textureShape;if(!u.arraysEqual(r,n))throw Error("Binary was compiled with different shapes than "+`the current args. Shapes ${r} and ${n} must match`);if(!u.arraysEqual(o,s))throw Error("Binary was compiled with different texture shapes than the"+` current args. Shape ${o} and ${s} must match`)})}function r(t,r,o,n){a(t.inShapeInfos,r),a([t.outShapeInfo],[o]);const u=o.texData.texture,s=o.texData.textureShape,i=t.gpgpu;i.setOutputMatrixTexture(u,s[0],s[1]),i.setProgram(t.webGLProgram),r.forEach((e,a)=>{const r=e.texData.texture,o=t.program.variableNames[a],n=t.uniformLocations[o];i.setInputMatrixTexture(r,n,a)}),e()&&i.gl.uniform1f(t.uniformLocations[p],NaN),null!=n&&n(i,t.webGLProgram),i.executeProgram(t.attributeLocations)}function o(e,t,a){let r="";t.concat(a).forEach(e=>{r+=`${e.array.shape}_${e.texData.textureShape}_${e.texData.textureType}`});const o=e.userCode,n=(!0===e.supportsBroadcasting).toString();let u=e.constructor.name;return u+="_"+n+"_"+r+"_"+o}Object.defineProperty(exports,"__esModule",{value:!0});const n=require("../../../environment"),u=require("../../../util"),s=require("./shader_compiler"),i=["uv","clipSpacePos"],p="NaN";exports.compileProgram=t,exports.runProgram=r,exports.makeShaderKey=o;
},{"../../../environment":15,"../../../util":24,"./shader_compiler":60}],47:[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0});class n{constructor(n){this.variableNames=["dy","maxPos"],this.outputShape=n.inShape;const t=n.filterHeight,o=n.filterWidth,e=n.strideHeight,d=n.strideWidth,i=t-1-n.padInfo.top,r=o-1-n.padInfo.left,a=t*o-1;this.userCode=`\n      const ivec2 pads = ivec2(${i}, ${r});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${t}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${e}.0;\n\n          if (dyR < 0.0 || dyR >= ${n.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${o}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${d}.0;\n\n            if (dyC < 0.0 || dyC >= ${n.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n            int maxPosValue = ${a} - int(getMaxPos(b, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            int curPosValue = wR * ${o} + wC;\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}exports.MaxPool2DBackpropProgram=n;
},{}],46:[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0});const t=require("../../types");class n{constructor(n,e,i=t.MatrixOrientation.REGULAR,r=t.MatrixOrientation.REGULAR){this.variableNames=["matrixA","matrixB"];const a=i===t.MatrixOrientation.REGULAR?n[0]:n[1],o=r===t.MatrixOrientation.REGULAR?e[1]:e[0];this.outputShape=[a,o];const x=i===t.MatrixOrientation.REGULAR?n[1]:n[0],$=(n,e)=>i===t.MatrixOrientation.REGULAR?`aRow, ${e} + ${n}`:`${e} + ${n}, aRow`,M=(n,e)=>r===t.MatrixOrientation.REGULAR?`${e} + ${n}, bCol`:`bCol, ${e} + ${n}`,s=4*Math.floor(x/4),g=x%4;this.userCode=` float dotARowBCol(int aRow, int bCol) {\n      float result = 0.0;\n      for (int i = 0; i < ${s}; i += 4) {\n        vec4 a = vec4(\n          getMatrixA(${$(0,"i")}),\n          getMatrixA(${$(1,"i")}),\n          getMatrixA(${$(2,"i")}),\n          getMatrixA(${$(3,"i")})\n        );\n        vec4 b = vec4(\n          getMatrixB(${M(0,"i")}),\n          getMatrixB(${M(1,"i")}),\n          getMatrixB(${M(2,"i")}),\n          getMatrixB(${M(3,"i")})\n        );\n\n        result += dot(a, b);\n      }\n\n      if (${1===g}) {\n        result += getMatrixA(${$(0,s)}) *\n          getMatrixB(${M(0,s)});\n      } else if (${2===g}) {\n        vec2 a = vec2(\n          getMatrixA(${$(0,s)}),\n          getMatrixA(${$(1,s)})\n        );\n        vec2 b = vec2(\n          getMatrixB(${M(0,s)}),\n          getMatrixB(${M(1,s)})\n        );\n        result += dot(a, b);\n      } else if (${3===g}) {\n        vec3 a = vec3(\n          getMatrixA(${$(0,s)}),\n          getMatrixA(${$(1,s)}),\n          getMatrixA(${$(2,s)})\n        );\n        vec3 b = vec3(\n          getMatrixB(${M(0,s)}),\n          getMatrixB(${M(1,s)}),\n          getMatrixB(${M(2,s)})\n        );\n        result += dot(a, b);\n      }\n\n      return result;\n    }\n\n    void main() {\n      ivec2 resRC = getOutputCoords();\n      setOutput(dotARowBCol(resRC.x, resRC.y));\n    }\n    `}}exports.MatMulProgram=n;
},{"../../types":19}],48:[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0});class t{constructor(t,e,n){this.variableNames=["probs"],this.outputShape=[t,n],this.userCode=`\n      uniform float seed;\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n\n        float r = random(seed);\n        float cdf = 0.0;\n\n        for (int i = 0; i < ${e-1}; i++) {\n          cdf += getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutput(float(i));\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutput(float(${e-1}));\n      }\n    `}getCustomSetupFunc(t){return(e,n)=>{null==this.seedLoc&&(this.seedLoc=e.getUniformLocation(n,"seed")),e.gl.uniform1f(this.seedLoc,t)}}}exports.MultinomialProgram=t;
},{}],49:[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0});class e{constructor(e,t,o,s){this.variableNames=["indices"],this.outputShape=[e,t],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int index = round(getIndices(coords.x));\n        setOutput(mix(float(${s}), float(${o}),\n                      float(index == coords.y)));\n      }\n    `}getCustomSetupFunc(e){return(t,o)=>{null==this.seedLoc&&(this.seedLoc=t.getUniformLocation(o,"seed")),t.gl.uniform1f(this.seedLoc,e)}}}exports.OneHotProgram=e;
},{}],50:[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0});class n{constructor(n,e,t){if(this.variableNames=["x"],"avg"===e&&t)throw new Error("Cannot compute positions for average pool.");const i=n.filterHeight,a=n.filterWidth,o=n.strideHeight,u=n.strideWidth,r=n.padInfo.top,l=n.padInfo.left;this.outputShape=n.outShape;const x="avg"===e;let s="0.0";if(x||(s="min"===e?"1.0 / 0.0":"-1.0 / 0.0"),t){const t="min"===e?"<=":">=";return void(this.userCode=`\n        const ivec2 strides = ivec2(${o}, ${u});\n        const ivec2 pads = ivec2(${r}, ${l});\n\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int batch = coords[0];\n          int d = coords[3];\n\n          ivec2 xRCCorner = coords.yz * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < ${i}; wR++) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${n.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${a}; wC++) {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= ${n.inWidth}) {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, d);\n\n              if (isNaN(value)) {\n                setOutput(value);\n                return;\n              }\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value ${t} currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = wR * ${a} + wC;\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `)}const c="min"===e?"min":"max";let d=`${e}(${e}(${e}(`+"minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";"avg"===e&&(d=`avgValue / ${i*a}.0`);const C=4*Math.floor(a/4),v=a%4,R=`\n      if (hasNaN(values)) {\n        setOutput(getNaN(values));\n        return;\n      }\n      if (${x}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = ${c}(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec2 strides = ivec2(${o}, ${u});\n      const ivec2 pads = ivec2(${r}, ${l});\n      const float initializationValue = ${s};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC < 0 || xC >= ${n.inWidth}) {\n          return initializationValue;\n        }\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${s});\n        float avgValue = 0.0;\n\n        for (int wR = 0; wR < ${i}; wR++) {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= ${n.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${C}; wC += 4) {\n            int xC = xCCorner + wC;\n\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + 1, d),\n              getValue(batch, xR, xC + 2, d),\n              getValue(batch, xR, xC + 3, d)\n            );\n\n            ${R}\n          }\n\n          int xC = xCCorner + ${C};\n          if (${1===v}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n            ${R}\n          } else if (${2===v}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + 1, d),\n              initializationValue,\n              initializationValue\n            );\n\n            ${R}\n          } else if (${3===v}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + 1, d),\n              getValue(batch, xR, xC + 2, d),\n              initializationValue\n            );\n\n            ${R}\n          }\n        }\n        setOutput(${d});\n      }\n    `}}exports.Pool2DProgram=n;
},{}],51:[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0});class n{constructor(n,e){this.variableNames=["x"];const i=n.windowSize,t=n.batchSize,a=n.inSize,u=Math.ceil(a/i);this.outputShape=[t,u];const l="sum"===e;let s="0.0";l||(s="min"===e?"1.0 / 0.0":"-1.0 / 0.0");const o="min"===e?"min":"max";let c=`${e}(${e}(${e}(`+"minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";"sum"===e&&(c="sumValue");const d=4*Math.floor(i/4),x=i%4,V=`\n      if (${l}) {\n        sumValue += dot(values, ones);\n      } else {\n        if (hasNaN(values)) {\n          setOutput(getNaN(values));\n          return;\n        }\n        minMaxValue = ${o}(values, minMaxValue);\n      }\n    `;let v="";a%i>0&&(v=`\n        if (inIdx < 0 || inIdx >= ${a}) {\n          return initializationValue;\n        }\n      `),this.userCode=`\n      const float initializationValue = ${s};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${v}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${i};\n\n        vec4 minMaxValue = vec4(${s});\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${d}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${V}\n        }\n\n        int inIdx = inOffset + ${d};\n        if (${1===x}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n          ${V}\n        } else if (${2===x}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n          ${V}\n        } else if (${3===x}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n          ${V}\n        }\n        setOutput(${c});\n      }\n    `}}exports.ReduceProgram=n;
},{}],52:[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0});class t{constructor(t,e,o){this.variableNames=["A"],this.outputShape=[];const n=t[2];this.outputShape=[e[0],e[1],n];const c=o?[t[0]-1,t[1]-1,n]:t,r=o?[this.outputShape[0]-1,this.outputShape[1]-1,n]:this.outputShape;this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${c[0]/r[0]},\n          ${c[1]/r[1]});\n      const vec2 inputShapeRC = vec2(${t[0]}.0, ${t[1]}.0);\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        ivec2 yRC = coords.xy;\n        int d = coords.z;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = vec2(yRC) * effectiveInputOverOutputRatioRC;\n\n        // Compute the four integer indices.\n        ivec2 sourceFloorRC = ivec2(sourceFracIndexRC);\n        ivec2 sourceCeilRC = ivec2(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        float topLeft = getA(sourceFloorRC.x, sourceFloorRC.y, d);\n        float bottomLeft = getA(sourceCeilRC.x, sourceFloorRC.y, d);\n        float topRight = getA(sourceFloorRC.x, sourceCeilRC.y, d);\n        float bottomRight = getA(sourceCeilRC.x, sourceCeilRC.y, d);\n\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n        float newValue = top + (bottom - top) * fracRC.x;\n\n        setOutput(newValue);\n      }\n    `}}exports.ResizeBilinear3DProgram=t;
},{}],53:[function(require,module,exports) {
"use strict";function t(t){if(1===t)return"sourceLoc";if(2===t)return"sourceLoc.x, sourceLoc.y";if(3===t)return"sourceLoc.x, sourceLoc.y, sourceLoc.z";if(4===t)return"sourceLoc.x, sourceLoc.y, sourceLoc.z, sourceLoc.w";throw Error(`Slicing for rank ${t} is not yet supported`)}Object.defineProperty(exports,"__esModule",{value:!0});const r=require("./shader_compiler");class o{constructor(o){this.variableNames=["source"],this.outputShape=o,this.rank=o.length;const s=r.getCoordsDataType(this.rank),e=t(this.rank);this.userCode=`\n      uniform ${s} start;\n\n      void main() {\n        ${s} sourceLoc = start + getOutputCoords();\n        setOutput(getSource(${e}));\n      }\n    `}getCustomSetupFunc(t){if(t.length!==this.rank)throw Error(`The rank (${this.rank}) of the program must match the `+`length of start (${t.length})`);return(r,o)=>{if(null!=this.startLoc||(this.startLoc=r.getUniformLocationNoThrow(o,"start"),null!=this.startLoc))if(1===this.rank)r.gl.uniform1i(this.startLoc,t[0]);else if(2===this.rank)r.gl.uniform2i(this.startLoc,t[0],t[1]);else if(3===this.rank)r.gl.uniform3i(this.startLoc,t[0],t[1],t[2]);else{if(4!==this.rank)throw Error(`Slicing for rank ${this.rank} is not yet supported`);r.gl.uniform4i(this.startLoc,t[0],t[1],t[2],t[3])}}}}exports.SliceProgram=o;
},{"./shader_compiler":60}],55:[function(require,module,exports) {
"use strict";function e(e){return`${e[0]}_${e[1]}`}Object.defineProperty(exports,"__esModule",{value:!0});class t{constructor(e){this.gpgpu=e,this.numUsedTextures=0,this.numFreeTextures=0,this.freeTextures={},this.logEnabled=!1,this.usedTextureCount={}}acquireTexture(t){const s=e(t);if(s in this.freeTextures||(this.freeTextures[s]=[]),s in this.usedTextureCount||(this.usedTextureCount[s]=0),this.usedTextureCount[s]++,this.freeTextures[s].length>0)return this.numFreeTextures--,this.numUsedTextures++,this.log(),this.freeTextures[s].shift();this.numUsedTextures++,this.log();return this.gpgpu.createMatrixTexture(t[0],t[1])}releaseTexture(t,s){const r=e(s);r in this.freeTextures||(this.freeTextures[r]=[]),this.freeTextures[r].push(t),this.numFreeTextures++,this.numUsedTextures--,this.usedTextureCount[r]--,this.log()}log(){if(!this.logEnabled)return;const e=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${e})`)}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){for(const e of Object.keys(this.freeTextures))for(const t of this.freeTextures[e])this.gpgpu.deleteMatrixTexture(t);this.freeTextures=null,this.usedTextureCount=null,this.numUsedTextures=0,this.numFreeTextures=0}}exports.TextureManager=t;
},{}],56:[function(require,module,exports) {
"use strict";function e(e){const t=e.length;if(t>4)throw Error(`Tile for rank ${t} is not yet supported`);if(1===t)return`imod(resRC, ${e[0]})`;const r=["resRC.x","resRC.y","resRC.z","resRC.w"],s=[];for(let t=0;t<e.length;t++)s.push(`imod(${r[t]}, ${e[t]})`);return s.join()}Object.defineProperty(exports,"__esModule",{value:!0});const t=require("./shader_compiler");class r{constructor(r,s){this.variableNames=["A"];const o=new Array(r.length);for(let e=0;e<o.length;e++)o[e]=r[e]*s[e];this.outputShape=o,this.rank=o.length;const n=t.getCoordsDataType(this.rank),i=e(r);this.userCode=`\n      void main() {\n        ${n} resRC = getOutputCoords();\n        setOutput(getA(${i}));\n      }\n    `}}exports.TileProgram=r;
},{"./shader_compiler":60}],57:[function(require,module,exports) {
"use strict";function e(e){const t=e.length;if(t>4)throw Error(`Transpose for rank ${t} is not yet supported`);const r=["resRC.x","resRC.y","resRC.z","resRC.w"],s=new Array(t);for(let t=0;t<e.length;t++)s[e[t]]=r[t];return s.join()}Object.defineProperty(exports,"__esModule",{value:!0});const t=require("./shader_compiler");class r{constructor(r,s){this.variableNames=["A"];const o=new Array(r.length);for(let e=0;e<o.length;e++)o[e]=r[s[e]];this.outputShape=o,this.rank=o.length;const n=t.getCoordsDataType(this.rank),a=e(s);this.userCode=`\n    void main() {\n      ${n} resRC = getOutputCoords();\n      setOutput(getA(${a}));\n    }\n    `}}exports.TransposeProgram=r;
},{"./shader_compiler":60}],58:[function(require,module,exports) {
"use strict";function n(n){return`\n    return (x >= 0.0) ? x : ${n} * x;\n  `}function r(n=0){return t+`\n    return x > 0.0 ? 1.0 : float(${n});\n  `}Object.defineProperty(exports,"__esModule",{value:!0});class e{constructor(n,r){this.variableNames=["A"],this.outputShape=n,this.userCode=`\n      float unaryOperation(float x) {\n        ${r}\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}}exports.UnaryOpProgram=e;const t="\n  if (isNaN(x)) return x;\n";exports.ABS="\n  return abs(x);\n",exports.RELU=t+"\n  return (x < 0.0) ? 0.0 : x;\n",exports.ELU="\n  return (x >= 0.0) ? x : (exp(x) - 1.0);\n",exports.ELU_DER="\n  return (x >= 0.0) ? 1.0 : exp(x);\n",exports.SELU="\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\n  // see: https://arxiv.org/abs/1706.02515\n  float scaleAlpha = 1.7580993408473768599402175208123;\n  float scale = 1.0507009873554804934193349852946;\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\n",exports.LEAKY_RELU=n,exports.STEP=r,exports.NEG="\n  return -x;\n",exports.CEIL="\n  return ceil(x);\n",exports.FLOOR="\n  return floor(x);\n",exports.EXP="\n  return exp(x);\n",exports.LOG="\n  return log(x);\n",exports.SQRT=t+"\n  return sqrt(x);\n",exports.SIGMOID="\n  return 1.0 / (1.0 + exp(-1.0 * x));\n",exports.SIN=t+"\n  return sin(x);\n",exports.COS=t+"\n  return cos(x);\n",exports.TAN="\n  return tan(x);\n",exports.ASIN=t+"\n  return asin(x);\n",exports.ACOS=t+"\n  return acos(x);\n",exports.ATAN=t+"\n  return atan(x);\n",exports.SINH="\n  float e2x = exp(x);\n  return (e2x - 1.0 / e2x) / 2.0;\n",exports.COSH="\n  float e2x = exp(-x);\n  return (e2x + 1.0 / e2x) / 2.0;\n",exports.TANH="\n  float e2x = exp(-2.0 * abs(x));\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\n",exports.SQUARE="\n  return x * x;\n",exports.TO_INT="\n  return float(int(x));\n";
},{}],21:[function(require,module,exports) {
"use strict";function e(e,t){if("float32"===t)return e;if("int32"===t||"bool"===t){const r="int32"===t?new Int32Array(e.length):new Uint8Array(e.length);for(let a=0;a<r.length;++a){let s=e[a];s=isNaN(s)?n.getNaN(t):Math.round(s),r[a]=s}return r}throw new Error(`Unknown dtype ${t}`)}function t(e,t){if(e instanceof Float32Array)return e;{const r=new Float32Array(e.length);for(let a=0;a<r.length;a++){const s=e[a];r[a]=n.isValNaN(s,t)?NaN:s}return r}}Object.defineProperty(exports,"__esModule",{value:!0});const r=require("../../environment"),n=require("../../util"),a=require("../axis_util"),s=require("../ndarray"),u=require("../reduce_util"),o=require("../types"),i=require("../types"),p=require("./webgl/argminmax_gpu"),h=require("./webgl/batchnorm_gpu"),l=require("./webgl/binaryop_gpu"),c=require("./webgl/binaryop_gpu"),m=require("./webgl/clip_gpu"),g=require("./webgl/concat_gpu"),d=require("./webgl/conv_backprop_gpu"),w=require("./webgl/conv_gpu"),y=require("./webgl/conv_gpu_depthwise"),A=require("./webgl/copy_gpu"),x=require("./webgl/gpgpu_context"),P=require("./webgl/gpgpu_math"),D=require("./webgl/gpgpu_util"),R=require("./webgl/max_pool_backprop_gpu"),O=require("./webgl/mulmat_gpu"),S=require("./webgl/multinomial_gpu"),E=require("./webgl/onehot_gpu"),b=require("./webgl/pool_gpu"),T=require("./webgl/reduce_gpu"),U=require("./webgl/resize_bilinear_gpu"),_=require("./webgl/slice_gpu"),N=require("./webgl/tex_util"),C=require("./webgl/texture_manager"),I=require("./webgl/tile_gpu"),M=require("./webgl/transpose_gpu"),f=require("./webgl/unaryop_gpu"),q=require("./webgl/unaryop_gpu"),B=require("./webgl/webgl_util");class L{constructor(e){if(this.gpgpu=e,this.texData=new WeakMap,this.binaryCache={},r.ENV.get("WEBGL_VERSION")<1)throw new Error("WebGL is not supported on this device");if(null==e){const e=D.createWebGLContext();this.gpgpu=new x.GPGPUContext(e),this.gpgpuCreatedLocally=!0}else this.gpgpuCreatedLocally=!1;"undefined"!=typeof document&&(this.canvas=document.createElement("canvas")),this.textureManager=new C.TextureManager(this.gpgpu)}register(e,t,r){if(this.texData.has(e))throw new Error(`data id ${e} already registered`);this.texData.set(e,{shape:t,dtype:r,values:null,texture:null,textureShape:null,textureType:null})}writePixels(e,t,r){if(null==t)throw new Error("MathBackendWebGL.writePixels(): pixels can not be null");this.throwIfNoData(e);const n=[t.height,t.width],a=this.texData.get(e).texture||this.textureManager.acquireTexture(n),{shape:s}=this.texData.get(e);if(this.texData.set(e,{shape:s,dtype:"int32",values:null,texture:a,textureShape:n,textureType:N.TextureType.RGBA_COLOR,numChannels:r}),t instanceof HTMLVideoElement){if(null==this.canvas)throw new Error("Can't read pixels from HTMLImageElement outside the browser.");this.canvas.width=t.width,this.canvas.height=t.height,this.canvas.getContext("2d").drawImage(t,0,0,t.width,t.height),t=this.canvas}this.gpgpu.uploadPixelDataToTexture(a,t)}write(e,t){if(null==t)throw new Error("MathBackendWebGL.write(): values can not be null");this.throwIfNoData(e);const{texture:r,textureShape:n}=this.texData.get(e);null!=r&&(this.textureManager.releaseTexture(r,n),Object.assign(this.texData.get(e),{texture:null,textureShape:null,textureType:null})),this.texData.get(e).values=t}readSync(e){this.throwIfNoData(e);const{texture:t,values:r,textureType:n,textureShape:a,numChannels:s}=this.texData.get(e);if(null!=r)return this.cacheOnCPU(e),r;let u;return u=n===N.TextureType.DEFAULT?this.gpgpu.downloadMatrixFromTexture(t,a[0],a[1]):this.gpgpu.downloadMatrixFromRGBAColorTexture(t,a[0],a[1],s),this.cacheOnCPU(e,u),this.texData.get(e).values}async read(e){this.throwIfNoData(e);const{texture:t,values:n,textureType:a,textureShape:s}=this.texData.get(e);if(null!=n)return this.cacheOnCPU(e),n;if(r.ENV.get("WEBGL_GET_BUFFER_SUB_DATA_ASYNC_EXTENSION_ENABLED")&&a===N.TextureType.DEFAULT){const r=await this.gpgpu.downloadMatrixFromTextureAsync(t,s[0],s[1]);return this.cacheOnCPU(e,r),this.texData.get(e).values}return r.ENV.get("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_ENABLED")?(await this.gpgpu.runQuery(()=>{}),this.readSync(e)):this.readSync(e)}async time(e){if(!r.ENV.get("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_ENABLED")){const t=performance.now(),r=e();return await r.data(),performance.now()-t}return this.gpgpu.runQuery(e)}disposeData(e){if(this.texData.has(e)){const{texture:t,textureShape:r}=this.texData.get(e);null!=t&&this.textureManager.releaseTexture(t,r),this.texData.delete(e)}}getTexture(e){return this.uploadToGPU(e),this.texData.get(e).texture}getTextureData(e){return this.uploadToGPU(e),this.texData.get(e)}getGPGPUContext(){return this.gpgpu}clone(e){this.throwIfNoData(e.dataId),this.uploadToGPU(e.dataId);const{textureShape:t}=this.texData.get(e.dataId),r=e.as2D(t[0],t[1]),n=this.makeOutputArray(t,e.dtype);return this.copy2D(r,[0,0],t,n,[0,0],t),n.reshape(e.shape)}slice1D(e,t,r){const n=new _.SliceProgram([r]),a=n.getCustomSetupFunc([t]);return this.compileAndRun(n,[e],null,a)}slice2D(e,t,r){const n=new _.SliceProgram(r),a=n.getCustomSetupFunc(t);return this.compileAndRun(n,[e],null,a)}slice3D(e,t,r){const n=new _.SliceProgram(r),a=n.getCustomSetupFunc(t);return this.compileAndRun(n,[e],null,a)}slice4D(e,t,r){const n=new _.SliceProgram(r),a=n.getCustomSetupFunc(t);return this.compileAndRun(n,[e],null,a)}copy2D(e,t,r,n,a,s){const u=new A.Copy2DProgram(r[1],s[1]),o=u.getCustomSetupFunc(t,a,s);this.compileAndRun(u,[e],n,o)}concat1D(e,t){const r=new g.ConcatProgram(e.shape,t.shape,0);return this.compileAndRun(r,[e,t])}concat2D(e,t,r){const n=new g.ConcatProgram(e.shape,t.shape,r);return this.compileAndRun(n,[e,t])}concat3D(e,t,r){const n=new g.ConcatProgram(e.shape,t.shape,r);return this.compileAndRun(n,[e,t])}concat4D(e,t,r){const n=new g.ConcatProgram(e.shape,t.shape,r);return this.compileAndRun(n,[e,t])}neg(e){const t=new q.UnaryOpProgram(e.shape,f.NEG);return this.compileAndRun(t,[e])}matMul(e,t,r,n){const a=new O.MatMulProgram(e.shape,t.shape,r,n);return this.compileAndRun(a,[e,t])}multiply(e,t){const r=new c.BinaryOpProgram(l.MUL,e.shape,t.shape),n=this.makeOutputArray(r.outputShape,o.upcastType(e.dtype,t.dtype));return this.compileAndRun(r,[e,t],n)}batchNormalization2D(e,t,r,n,a,s){const u=[e,t,r];let o=null;null!=s&&(o=s.shape,u.push(s));let i=null;null!=a&&(i=a.shape,u.push(a));const p=new h.BatchNormProgram(e.shape,t.shape,r.shape,o,i,n);return this.compileAndRun(p,u)}batchNormalization3D(e,t,r,n,a,s){const u=[e,t,r];let o=null;null!=s&&(o=s.shape,u.push(s));let i=null;null!=a&&(i=a.shape,u.push(a));const p=new h.BatchNormProgram(e.shape,t.shape,r.shape,o,i,n);return this.compileAndRun(p,u)}batchNormalization4D(e,t,r,n,a,s){const u=[e,t,r];let o=null;null!=s&&(o=s.shape,u.push(s));let i=null;null!=a&&(i=a.shape,u.push(a));const p=new h.BatchNormProgram(e.shape,t.shape,r.shape,o,i,n);return this.compileAndRun(p,u)}tile(e,t){const r=new I.TileProgram(e.shape,t);return this.compileAndRun(r,[e])}transpose(e,t){const r=new M.TransposeProgram(e.shape,t);return this.compileAndRun(r,[e])}reduce(e,t,r){const n=e.shape[0],a=e.shape[1],s={windowSize:u.computeOptimalWindowSize(a),inSize:a,batchSize:n},o=new T.ReduceProgram(s,t),[i,p]=o.outputShape,h=this.makeOutputArray(o.outputShape,r).as2D(i,p);return this.compileAndRun(o,[e],h),1===h.shape[1]?h:this.reduce(h,t,r)}argReduce(e,t,r=null){let n=e.shape[0],a=e.shape[1];null!=r&&(n=r.shape[0],a=r.shape[1]);const s={windowSize:u.computeOptimalWindowSize(a),inSize:a,batchSize:n},o=new p.ArgMinMaxProgram(s,t,null==r),[i,h]=o.outputShape,l=this.makeOutputArray(o.outputShape,"int32").as2D(i,h),c=[e];return null!=r&&c.push(r),this.compileAndRun(o,c,l),1===l.shape[1]?l:this.argReduce(e,t,l)}sum(e,t){a.assertAxesAreInnerMostDims("sum",t,e.rank);const[r,s]=a.computeOutAndReduceShapes(e.shape,t),u=n.sizeFromShape(s),o=e.as2D(-1,u),p=i.SumTypesMap[e.dtype];return this.reduce(o,"sum",p).reshape(r)}argMin(e,t){a.assertAxesAreInnerMostDims("argMin",t,e.rank);const[r,s]=a.computeOutAndReduceShapes(e.shape,t),u=n.sizeFromShape(s),o=e.as2D(-1,u);return this.argReduce(o,"min").reshape(r)}argMax(e,t){a.assertAxesAreInnerMostDims("argMax",t,e.rank);const[r,s]=a.computeOutAndReduceShapes(e.shape,t),u=n.sizeFromShape(s),o=e.as2D(-1,u);return this.argReduce(o,"max").reshape(r)}equal(e,t){const r=new c.BinaryOpProgram(l.EQUAL,e.shape,t.shape),n=this.makeOutputArray(r.outputShape,"bool");return this.compileAndRun(r,[e,t],n)}notEqual(e,t){const r=new c.BinaryOpProgram(l.NOT_EQUAL,e.shape,t.shape),n=this.makeOutputArray(r.outputShape,"bool");return this.compileAndRun(r,[e,t],n)}greater(e,t){const r=new c.BinaryOpProgram(l.GREATER,e.shape,t.shape),n=this.makeOutputArray(r.outputShape,"bool");return this.compileAndRun(r,[e,t],n)}greaterEqual(e,t){const r=new c.BinaryOpProgram(l.GREATER_EQUAL,e.shape,t.shape),n=this.makeOutputArray(r.outputShape,"bool");return this.compileAndRun(r,[e,t],n)}less(e,t){const r=new c.BinaryOpProgram(l.LESS,e.shape,t.shape),n=this.makeOutputArray(r.outputShape,"bool");return this.compileAndRun(r,[e,t],n)}lessEqual(e,t){const r=new c.BinaryOpProgram(l.LESS_EQUAL,e.shape,t.shape),n=this.makeOutputArray(r.outputShape,"bool");return this.compileAndRun(r,[e,t],n)}select(e,t,r){throw new Error("select GPU not yet implemented!")}topKValues(e,t){throw new Error("topKValues GPU not yet implemented!")}topKIndices(e,t){throw new Error("topKIndices GPU not yet implemented!")}min(e,t){a.assertAxesAreInnerMostDims("min",t,e.rank);const[r,s]=a.computeOutAndReduceShapes(e.shape,t),u=n.sizeFromShape(s),o=e.as2D(-1,u);return this.reduce(o,"min",o.dtype).reshape(r)}minimum(e,t){const r=new c.BinaryOpProgram(l.MIN,e.shape,t.shape);return this.compileAndRun(r,[e,t])}max(e,t){a.assertAxesAreInnerMostDims("max",t,e.rank);const[r,s]=a.computeOutAndReduceShapes(e.shape,t),u=n.sizeFromShape(s),o=e.as2D(-1,u);return this.reduce(o,"max",o.dtype).reshape(r)}maximum(e,t){const r=new c.BinaryOpProgram(l.MAX,e.shape,t.shape);return this.compileAndRun(r,[e,t])}divide(e,t){const r=new c.BinaryOpProgram(l.DIV,e.shape,t.shape),n=this.makeOutputArray(r.outputShape,"float32");return this.compileAndRun(r,[e,t],n)}add(e,t){const r=new c.BinaryOpProgram(l.ADD,e.shape,t.shape),n=this.makeOutputArray(r.outputShape,o.upcastType(e.dtype,t.dtype));return this.compileAndRun(r,[e,t],n)}subtract(e,t){const r=new c.BinaryOpProgram(l.SUB,e.shape,t.shape),n=this.makeOutputArray(r.outputShape,o.upcastType(e.dtype,t.dtype));return this.compileAndRun(r,[e,t],n)}pow(e,t){const r=new c.BinaryOpProgram(l.POW,e.shape,t.shape),n=this.makeOutputArray(r.outputShape,o.upcastType(e.dtype,t.dtype));return this.compileAndRun(r,[e,t],n)}ceil(e){const t=new q.UnaryOpProgram(e.shape,f.CEIL);return this.compileAndRun(t,[e])}floor(e){const t=new q.UnaryOpProgram(e.shape,f.FLOOR);return this.compileAndRun(t,[e])}exp(e){const t=new q.UnaryOpProgram(e.shape,f.EXP);return this.compileAndRun(t,[e])}log(e){const t=new q.UnaryOpProgram(e.shape,f.LOG);return this.compileAndRun(t,[e])}sqrt(e){const t=new q.UnaryOpProgram(e.shape,f.SQRT);return this.compileAndRun(t,[e])}square(e){const t=new q.UnaryOpProgram(e.shape,f.SQUARE);return this.compileAndRun(t,[e])}relu(e){const t=new q.UnaryOpProgram(e.shape,f.RELU);return this.compileAndRun(t,[e])}elu(e){const t=new q.UnaryOpProgram(e.shape,f.ELU);return this.compileAndRun(t,[e])}eluDer(e){const t=new q.UnaryOpProgram(e.shape,f.ELU_DER);return this.compileAndRun(t,[e])}selu(e){const t=new q.UnaryOpProgram(e.shape,f.SELU);return this.compileAndRun(t,[e])}leakyRelu(e,t){const r=new q.UnaryOpProgram(e.shape,f.LEAKY_RELU(t));return this.compileAndRun(r,[e])}prelu(e,t){const r=new c.BinaryOpProgram(l.PRELU,e.shape,t.shape);return this.compileAndRun(r,[e,t])}preluDer(e,t){const r=new c.BinaryOpProgram(l.PRELU_DER,e.shape,t.shape);return this.compileAndRun(r,[e,t])}int(e){const t=new q.UnaryOpProgram(e.shape,f.TO_INT),r=this.makeOutputArray(t.outputShape,"int32");return this.compileAndRun(t,[e],r)}clip(e,t,r){const n=new m.ClipProgram(e.shape,t,r);return this.compileAndRun(n,[e])}abs(e){const t=new q.UnaryOpProgram(e.shape,f.ABS);return this.compileAndRun(t,[e])}sigmoid(e){const t=new q.UnaryOpProgram(e.shape,f.SIGMOID);return this.compileAndRun(t,[e])}sin(e){const t=new q.UnaryOpProgram(e.shape,f.SIN);return this.compileAndRun(t,[e])}cos(e){const t=new q.UnaryOpProgram(e.shape,f.COS);return this.compileAndRun(t,[e])}tan(e){const t=new q.UnaryOpProgram(e.shape,f.TAN);return this.compileAndRun(t,[e])}asin(e){const t=new q.UnaryOpProgram(e.shape,f.ASIN);return this.compileAndRun(t,[e])}acos(e){const t=new q.UnaryOpProgram(e.shape,f.ACOS);return this.compileAndRun(t,[e])}atan(e){const t=new q.UnaryOpProgram(e.shape,f.ATAN);return this.compileAndRun(t,[e])}sinh(e){const t=new q.UnaryOpProgram(e.shape,f.SINH);return this.compileAndRun(t,[e])}cosh(e){const t=new q.UnaryOpProgram(e.shape,f.COSH);return this.compileAndRun(t,[e])}tanh(e){const t=new q.UnaryOpProgram(e.shape,f.TANH);return this.compileAndRun(t,[e])}step(e,t){const r=new q.UnaryOpProgram(e.shape,f.STEP(t));return this.compileAndRun(r,[e])}conv2d(e,t,r,n){const a=new w.Conv2DProgram(n,null!=r),s=null!=r?[e,t,r]:[e,t];return this.compileAndRun(a,s)}conv2dDerInput(e,t,r){const n=new d.Conv2DDerInputProgram(r);return this.compileAndRun(n,[e,t])}conv2dDerFilter(e,t,r){const n=new d.Conv2DDerFilterProgram(r);return this.compileAndRun(n,[e,t])}conv2dDerBias(e){const t=new d.Conv2DDerBiasProgram(e.shape);return this.compileAndRun(t,[e])}depthwiseConv2D(e,t,r){const n=new y.DepthwiseConv2DProgram(r);return this.compileAndRun(n,[e,t])}maxPool(e,t){const r=new b.Pool2DProgram(t,"max",!1);return this.compileAndRun(r,[e])}minPool(e,t){const r=new b.Pool2DProgram(t,"min",!1);return this.compileAndRun(r,[e])}avgPool(e,t){const r=new b.Pool2DProgram(t,"avg",!1);return this.compileAndRun(r,[e])}maxPoolBackprop(e,t,r){const n=new b.Pool2DProgram(r,"max",!0),a=this.compileAndRun(n,[t]),s=new R.MaxPool2DBackpropProgram(r),u=this.compileAndRun(s,[e,a]);return a.dispose(),u}resizeBilinear3D(e,t,r){const n=new U.ResizeBilinear3DProgram(e.shape,t,r);return this.compileAndRun(n,[e])}multinomial(e,t,r){const n=e.shape[0],a=e.shape[1],s=new S.MultinomialProgram(n,a,t),u=this.makeOutputArray(s.outputShape,"int32"),o=s.getCustomSetupFunc(r);return this.compileAndRun(s,[e],u,o)}oneHot(e,t,r,n){const a=new E.OneHotProgram(e.size,t,r,n);return this.compileAndRun(a,[e])}setDiag(e,t){throw new Error("setDiag GPU not yet implemented!")}makeOutputArray(e,t){return s.NDArray.make(e,{},t)}compileAndRun(e,t,r,n){null==r&&(r=this.makeOutputArray(e.outputShape,t[0].dtype));const a=t.map(e=>(this.uploadToGPU(e.dataId),{array:e,texData:this.texData.get(e.dataId)}));this.uploadToGPU(r.dataId);const s={array:r,texData:this.texData.get(r.dataId)},u=P.makeShaderKey(e,a,s),o=this.getAndSaveBinary(u,()=>P.compileProgram(this.gpgpu,e,a,s));return P.runProgram(o,a,s,n),r}getAndSaveBinary(e,t){return e in this.binaryCache||(this.binaryCache[e]=t()),this.binaryCache[e]}getTextureManager(){return this.textureManager}dispose(){for(const e in this.binaryCache)this.binaryCache.hasOwnProperty(e)&&this.gpgpu.deleteProgram(this.binaryCache[e].webGLProgram);this.textureManager.dispose(),this.gpgpuCreatedLocally&&this.gpgpu.dispose()}throwIfNoData(e){if(!this.texData.has(e))throw new Error(`No data found for NDArray with data id ${e}. `+"Use dl.ENV.math instead of constructing your own NDArrayMath. If you need to construct your own math, make sure this array is allocated after the math construction")}uploadToGPU(e){this.throwIfNoData(e);const{shape:r,values:n,texture:a,dtype:s}=this.texData.get(e);if(null!=a)return;const u=B.getTextureShapeFromLogicalShape(this.gpgpu.gl,r);this.texData.get(e).textureType=N.TextureType.DEFAULT,this.texData.get(e).textureShape=u;const o=this.textureManager.acquireTexture(u);this.texData.get(e).texture=o,null!=n&&this.gpgpu.uploadMatrixToTexture(o,u[0],u[1],t(n,s))}cacheOnCPU(t,r){const{texture:n,textureShape:a,dtype:s}=this.texData.get(t);null!=n&&(this.textureManager.releaseTexture(n,a),Object.assign(this.texData.get(t),{texture:null,textureShape:null,textureType:null})),null!=r&&(this.texData.get(t).values=e(r,s))}}exports.MathBackendWebGL=L,r.ENV.registerBackend("webgl",()=>new L);
},{"../../environment":15,"../../util":24,"../axis_util":28,"../ndarray":17,"../reduce_util":33,"../types":19,"./webgl/argminmax_gpu":35,"./webgl/batchnorm_gpu":34,"./webgl/binaryop_gpu":36,"./webgl/clip_gpu":37,"./webgl/concat_gpu":38,"./webgl/conv_backprop_gpu":39,"./webgl/conv_gpu":40,"./webgl/conv_gpu_depthwise":41,"./webgl/copy_gpu":42,"./webgl/gpgpu_context":43,"./webgl/gpgpu_math":44,"./webgl/gpgpu_util":45,"./webgl/max_pool_backprop_gpu":47,"./webgl/mulmat_gpu":46,"./webgl/multinomial_gpu":48,"./webgl/onehot_gpu":49,"./webgl/pool_gpu":50,"./webgl/reduce_gpu":51,"./webgl/resize_bilinear_gpu":52,"./webgl/slice_gpu":53,"./webgl/tex_util":54,"./webgl/texture_manager":55,"./webgl/tile_gpu":56,"./webgl/transpose_gpu":57,"./webgl/unaryop_gpu":58,"./webgl/webgl_util":59}],8:[function(require,module,exports) {
"use strict";function r(r){return r instanceof Float32Array||r instanceof Uint8Array||r instanceof Int32Array}function t(r){if(r instanceof Int32Array)return"int32";if(r instanceof Float32Array)return"float32";if(r instanceof Uint8Array)return"uint8";throw new Error("Unsupported TypedArray flavor")}function e(r,t="float32"){switch(t){case"bool":return new Uint8Array(r);case"float32":return new Float32Array(r);case"int32":return new Int32Array(r);case"uint8":return new Uint8Array(r);default:throw new Error("Not implemented")}}Object.defineProperty(exports,"__esModule",{value:!0}),exports.isTypedArray=r,exports.getDType=t,exports.makeTypedArray=e;
},{}],11:[function(require,module,exports) {
"use strict";function e(e,t){return e.toFixed(t).replace(/0+$/,"").split(".",2)}function t(e,t,r){const n=o.getDType(t);let l=0,s=0;for(let e=0;e<t.length;e++){const[n,o]=t[e].toFixed(r).replace(/0+$/,"").split(".",2);l<n.length&&(l=n.length),s<o.length&&(s=o.length)}return{precision:r,dtype:n,maxBefore:l,maxAfter:s}}function r(t,r){switch(r.dtype){case"int32":case"uint8":return""+t;case"float32":const[n,o]=e(t,r.precision),l=1+r.maxBefore-n.length,s=r.maxAfter-o.length;return" ".repeat(l)+n+"."+o+" ".repeat(s);default:throw new Error("Bad dtype.")}}function n(e,n){let o;const l=t(e,n,3);switch(e.length){case 0:return r(n[0],l);case 1:o="[";for(let t=0;t<e[0];t++)o+=0===t?"":", ",o+=r(n[t],l);return o+="]";case 2:let t=1;for(let o=0;o<e[0];o++)for(let s=0;s<e[1];s++){const c=r(n[o*e[1]+s],l);c.length>t&&(t=c.length)}o="[";for(let s=0;s<e[0];s++){o+=0===s?"[":"\n [";for(let c=0;c<e[1];c++){const a=r(n[s*e[1]+c],l);o+=0===c?"":", ",o+=a.padStart(t)}o+="]",s!==e[0]-1&&(o+=",")}return o+="]";default:return"Tensor(["+e+"])"}}Object.defineProperty(exports,"__esModule",{value:!0});const o=require("./types");exports.toString=n;
},{"./types":8}],3:[function(require,module,exports) {
"use strict";function t(t){const o=t.inputIds.toString(),e=t.outputIds.toString();return`${t.name}(${t.oid}) in ${o} out ${e}`}function o(t,o){const e=n(t,o);return function(...t){return e(...t)[0]}}function e(t,o){return function(e){if(i(),o)for(const t of o)a(e.get(t));else e.forEach((t,o)=>a(t));let n=t(e);n=h.convert(n);const s=[],r=[];e.forEach((t,o)=>{s.push(o),r.push(t)});const c=p(n,r);g.assert(c.length===s.length);const u=new l.Params;for(let t=0;t<s.length;++t){const o=s[t];u.set(o,c[t])}return[u,n]}}function n(t,o){return function(...e){i();const n=e.map(t=>h.convert(t));if(null==o)for(const t of n)a(t);else for(const t of o)a(n[t]);let s=t.apply(null,n);return s=h.convert(s),[p(s,n),s]}}function s(t,o=0){const e=n(t,[o]);return function(...t){return e(...t)[0][0]}}function r(t,o=0){const e=n(t,[o]);return function(...t){const[o,n]=e(...t);return[o[0],n]}}function p(o,e){const n=u(),s=[],r=new Set(e.map(t=>t.id)),[p,i,a]=c(o,n,r);g.log("usageCounts",p),g.log("opMissingTensor",i);const d=n.tensorToOp.get(o.id);d&&s.push(d);const O=new m;for(O.append(o.id,o.onesLike());s.length>0;){const o=s.pop(),e=a.get(o);g.assertEqual(e.outputIds.length,1);const c=O.aggregate(e.outputIds[0]);g.log("backprop",t(e)),g.log("- outGrad %s",c.shape,c.device);const u=f.getBackwardFuncs(e.name).map((t,o)=>{if(t)return t(c,...e.savedForBackward||[]);{const t=e.inputShapeDTypes[o],n=h.convert(0,{dtype:t[1],device:c.device});return l.fill(n,t[0])}});g.log("- inGrad",u.map(t=>t?[t.device,t.shape]:null));for(let t=0;t<e.inputIds.length;t++){const o=e.inputIds[t];if(null!==o&&null!=u[t]){if(g.assert(null!=u[t],`inGrads[${t}] = null but tid = ${o}`),O.append(o,u[t]),p.get(o)>0&&(p.dec(o),n.tensorToOp.has(o)&&0===p.get(o)&&!r.has(o))){const t=n.tensorToOp.get(o);t>0&&i.get(t)>0&&(i.dec(t),0===i.get(t)&&s.push(t))}}else g.log("- null inGrad[%d] ",t,u[t],"tid",o)}}const T=[];for(const t of e){const o=O.aggregate(t.id);g.log("- result",t.id,o.shape,o.device),T.push(o)}return T}function c(t,o,e){const n=[t.id],s=new Map,r=new g.CounterMap;for(;n.length>0;){const t=n.pop(),p=o.tensorToOp.get(t);if(void 0===p||p<0||s.has(p))continue;const c=o.oidLookup.get(p);s.set(p,c);for(const t of c.inputIds)r.inc(t),1===r.get(t)&&o.tensorToOp.has(t)&&!e.has(t)&&n.push(t)}const p=new g.CounterMap;for(const t of r.keys())if(o.tensorToOp.has(t)&&o.tensorToOp.get(t)>0){const e=o.tensorToOp.get(t);p.inc(e)}return[r,p,s]}function i(){O.push(new T)}function u(){return O.pop()}function a(t){for(const o of O)o.watch(t)}function d(t){for(const o of O)o.recordOp(t)}Object.defineProperty(exports,"__esModule",{value:!0});const l=require("./api"),f=require("./ops"),h=require("./tensor"),g=require("./util"),O=[];class T{constructor(){this.tensorToOp=new Map,this.oidLookup=new Map}shouldRecord(t){for(const o of t)if(this.tensorToOp.has(o))return!0;return!1}watch(t){const o=t.id;this.tensorToOp.has(o)||this.tensorToOp.set(o,-1),g.log("- watch tensor id",o,t.device)}recordOp(o){if(this.shouldRecord(o.inputIds)){g.log("recordOp %s",t(o));for(const t of o.outputIds)this.tensorToOp.set(t,o.oid);this.oidLookup.set(o.oid,o)}}}exports.Tape=T,exports.multigrad=o,exports.gradParams=e,exports.multigradAndVal=n,exports.grad=s,exports.gradAndVal=r,exports.pushNewTape=i,exports.popTape=u,exports.recordOp=d;class m{constructor(){this.map=new Map}append(t,o){g.log("- GradientCollector append",t,o.shape,o.device),this.map.has(t)?this.map.get(t).push(o):this.map.set(t,[o])}aggregate(t){if(!this.map.has(t)||0===this.map.get(t).length)return h.convert(0);const o=this.map.get(t);let e=o[0];for(let t=1;t<o.length;t++)e=e.add(o[t]);return e}}exports.GradientCollector=m;
},{"./api":1,"./ops":4,"./tensor":6,"./util":2}],4:[function(require,module,exports) {
"use strict";function e(e,s){const t=(...t)=>{const o=[],u=t.map(e=>e.id?(o.push(e),e.id):null),n=t.map(e=>{if(e.shape){const r=e;return[r.shape,r.dtype]}return null}),a=t.map(e=>e.basic?e.basic:e),l=s(...a),p=new x.Tensor(l);o.push(p);const d=r(b,o);return b=null,c.recordOp({name:e,oid:i++,inputIds:u,inputShapeDTypes:n,outputIds:[p.id],savedForBackward:d}),p};return m[e]={name:e,opFunc:t,bwFuncs:null},t}function r(e,r){return e?e.map(e=>{if(e.getData){const s=e;for(const e of r)if(e.basic===s)return e;throw new Error("Couldn't find corresponding Tensor.")}return e}):null}function s(e,...r){m[e].bwFuncs=r}function t(...e){d.assert(null===b),b=e}function o(e){return m[e].bwFuncs}function u(e,r){return exports.fill(x.convert(1,r),e)}function n(e,r){return exports.fill(x.convert(0,r),e)}function a(e){return(r,s,t)=>{if(d.shapesEqual(s,t))return r;const[o,u]=d.bcastGradientArgs(s,t);return e?r.reduceSum(o).reshape(s):r.reduceSum(u).reshape(t)}}function l(e,r){return(s,t,o)=>{if(s=r?e?s.mul(o):s.mul(t):e?s.div(o):s.mul(t).neg().div(o.square()),d.shapesEqual(t.shape,o.shape))return s;const[u,n]=d.bcastGradientArgs(t.shape,o.shape);return e?s.reduceSum(u).reshape(t.shape):s.reduceSum(n).reshape(o.shape)}}Object.defineProperty(exports,"__esModule",{value:!0});const p=require("./backend"),c=require("./backprop"),x=require("./tensor"),d=require("./util");let i=1;const m={};let b=null;exports.getBackwardFuncs=o,exports.ones=u,exports.zeros=n,exports.add=e("add",(e,r)=>(t(e.shape,r.shape),p.bo.add(e,r))),s("add",(e,r,s)=>a(!0)(e,r,s),(e,r,s)=>a(!1)(e,r,s)),exports.sub=e("sub",(e,r)=>(t(e.shape,r.shape),p.bo.sub(e,r))),s("sub",(e,r,s)=>a(!0)(e,r,s),(e,r,s)=>a(!1)(e,r,s).neg()),exports.mul=e("mul",(e,r)=>(t(e,r),p.bo.mul(e,r))),s("mul",(e,r,s)=>l(!0,!0)(e,r,s),(e,r,s)=>l(!1,!0)(e,r,s)),exports.div=e("div",(e,r)=>(t(e,r),p.bo.div(e,r))),s("div",(e,r,s)=>l(!0,!1)(e,r,s),(e,r,s)=>l(!1,!1)(e,r,s)),exports.matmul=e("matmul",(e,r,s=!1,o=!1)=>(t(e,r,s,o),p.bo.matmul(e,r,s,o))),s("matmul",(e,r,s,t,o)=>exports.matmul(e,s,t,!o),(e,r,s,t,o)=>exports.matmul(r,e,!t,o)),exports.neg=e("neg",e=>p.bo.neg(e)),s("neg",e=>exports.neg(e)),exports.exp=e("exp",e=>{const r=p.bo.exp(e);return t(r),r}),s("exp",(e,r)=>exports.mul(r,e)),exports.log=e("log",e=>(t(e),p.bo.log(e))),s("log",(e,r)=>exports.div(e,r)),exports.fill=e("fill",(e,r)=>(t(e),p.bo.fill(e,r))),s("fill",(e,r)=>{throw new Error("Not Implemented: backward pass of fill.")}),exports.square=e("square",e=>(t(e),p.bo.square(e))),s("square",(e,r)=>{const s=x.convert(2,r);return e.mul(r.mul(s))}),exports.sinh=e("sinh",e=>(t(e),p.bo.sinh(e))),s("sinh",(e,r)=>exports.mul(e,exports.cosh(r))),exports.cosh=e("cosh",e=>(t(e),p.bo.cosh(e))),s("cosh",(e,r)=>exports.mul(e,exports.sinh(r))),exports.tanh=e("tanh",e=>(t(e),p.bo.tanh(e))),s("tanh",(e,r)=>exports.div(e,exports.square(exports.cosh(r)))),exports.relu=e("relu",e=>(t(e),p.bo.relu(e))),s("relu",(e,r)=>exports.reluGrad(e,r)),exports.reluGrad=e("reluGrad",(e,r)=>(t(r),p.bo.reluGrad(e,r))),s("reluGrad",(e,r)=>exports.reluGrad(e,r),null),exports.sigmoid=e("sigmoid",e=>{const r=p.bo.sigmoid(e);return t(r),r}),s("sigmoid",(e,r)=>e.mul(r.sub(r.square()))),exports.abs=e("abs",e=>(t(e),p.bo.abs(e))),s("abs",(e,r)=>{const s=r.zerosLike();return r.greater(s).select(e,e.neg())}),exports.transpose=e("transpose",(e,r)=>(t(r),p.bo.transpose(e,r))),s("transpose",(e,r)=>exports.transpose(e,r)),exports.reverse=e("reverse",(e,r)=>(t(r),p.bo.reverse(e,r))),s("reverse",(e,r)=>exports.reverse(e,r)),exports.argmax=e("argmax",(e,r)=>p.bo.argmax(e,r)),s("argmax",null),exports.argmin=e("argmin",(e,r)=>p.bo.argmin(e,r)),s("argmin",null),exports.reduceSum=e("reduceSum",(e,r,s)=>(t(e.shape,e.dtype,r),p.bo.reduceSum(e,r,s))),s("reduceSum",(e,r,s,t)=>{const o=r.slice();for(const e of t){o[e<0?r.length+e:e]=1}return e.reshape(o).mul(u(r,s))}),exports.reduceMean=e("reduceMean",(e,r,s)=>(t(r,e.shape,e.dtype),p.bo.reduceMean(e,r,s))),s("reduceMean",(e,r,s,t)=>{let o=1;const u=s.slice();for(const e of r){const r=e<0?s.length+e:e;o*=s[r],u[r]=1}const n=x.convert(1/o,{dtype:"float32",device:e.device});return e.reshape(u).mul(exports.fill(n,s))}),exports.reduceMax=e("reduceMax",(e,r,s)=>p.bo.reduceMax(e,r,s)),s("reduceMax",(e,r,s)=>{throw new Error("Not Implemented.")}),exports.equal=e("equal",(e,r)=>p.bo.equal(e,r)),s("equal",null,null),exports.greater=e("greater",(e,r)=>p.bo.greater(e,r)),s("greater",null,null),exports.greaterEqual=e("greaterEqual",(e,r)=>p.bo.greaterEqual(e,r)),s("greaterEqual",null,null),exports.less=e("less",(e,r)=>p.bo.less(e,r)),s("less",null,null),exports.lessEqual=e("lessEqual",(e,r)=>p.bo.lessEqual(e,r)),s("lessEqual",null,null),exports.select=e("select",(e,r,s)=>(t(e),p.bo.select(e,r,s))),s("select",null,(e,r)=>r.cast(e.dtype).mul(e),(e,r)=>r.cast(e.dtype).neg().add(1).mul(e)),exports.sign=e("sign",e=>p.bo.sign(e)),s("sign",null),exports.slice=e("slice",(e,r,s)=>(t(e.shape,r,s),p.bo.slice(e,r,s))),s("slice",(e,r,s,t)=>{throw new Error("Not Implemented.")}),exports.reshape=e("reshape",(e,r)=>(t(e.shape),p.bo.reshape(e,r))),s("reshape",(e,r)=>e.reshape(r)),exports.reduceLogSumExp=e("reduceLogSumExp",(e,r,s=!1)=>{const o=p.bo.reduceMax(e,r,!0),u=p.bo.exp(p.bo.sub(e,o)),n=p.bo.reduceSum(u,r,!0),a=p.bo.log(n),l=p.bo.add(o,a);return t(l,e),l}),s("reduceLogSumExp",(e,r,s)=>e.mul(exports.exp(s.sub(r)))),exports.softmax=e("softmax",e=>{d.assert(2===e.shape.length);const r=p.bo.softmax(e);return t(r),r}),s("softmax",(e,r)=>e.sub(e.mul(r).reduceSum([1]).reshape([-1,1])).mul(r)),exports.logSoftmax=e("logSoftmax",e=>{d.assert(2===e.shape.length);const r=p.bo.logSoftmax(e);return t(r),r}),s("logSoftmax",(e,r)=>{const s=r.exp();return e.sub(e.reduceSum([1],!0).mul(s))}),exports.cast=e("cast",(e,r)=>(t(e.dtype),p.bo.cast(e,r))),s("cast",(e,r)=>e.cast(r)),exports.oneHot=e("oneHot",(e,r,s,t)=>p.bo.oneHot(e,r,s,t)),s("oneHot",null),exports.setDiag=e("setDiag",(e,r)=>p.bo.setDiag(e,r)),s("setDiag",e=>{throw new Error("Not Implemented.")},e=>{throw new Error("Not Implemented.")});
},{"./backend":7,"./backprop":3,"./tensor":6,"./util":2}],6:[function(require,module,exports) {
"use strict";function t(t,e){return t instanceof l?t:new l(h.convertBasic(t,e))}function e(t){const e=new Array(t);for(let s=0;s<t;s++)e[s]=s;return e}function s(t,e,s){if(-1!==e)throw new Error("Softmax along a non-last axis is not yet supported.");if(2===t.rank)return s(t,e);const r=t.shape,i=t.shape[t.rank-1];return s(t.reshape([-1,i])).reshape(r)}function r(t){const e=new p;d.push(e);const s=t=>{e.keep(t)};try{t(s)}finally{u.assert(e===d.pop()),e.clean()}}function i(t){d.length>0&&d[d.length-1].track(t)}function n(t){for(const e of d)e.untrack(t)}Object.defineProperty(exports,"__esModule",{value:!0});const a=require("./api"),h=require("./backend"),o=require("./format"),c=require("./ops"),u=require("./util");exports.convert=t;class l{constructor(t){this.basic=t,this.id=l.nextId++,i(this)}dispose(){this.basic.dispose(),this.basic=null,n(this)}assign(t){u.assertShapesEqual(t.shape,this.shape),u.assert(t.dtype===this.dtype),this.dispose(),this.basic=t.basic,t.basic=null}[Symbol.iterator](){const t=this.basic.getData();let e=0;return{next:()=>e<t.length?{value:t[e++],done:!1}:{value:null,done:!0}}}colocate(t,e){return t instanceof l?t.device===this.device?t:new l(h.bo.copyToDevice(t.basic,this.device)):new l(h.convertBasic(t,{dtype:e,device:this.device}))}getData(){return this.basic.getData()}get rank(){return this.shape.length}get device(){return h.bo.getDevice(this.basic)}get dtype(){return this.basic.dtype}get shape(){return this.basic.shape}toString(){return o.toString(this.shape,this.getData())}copy(t){t||(t=this.device);const e=h.bo.copyToDevice(this.basic,t);return new l(e)}gpu(){if("GPU:0"===this.device)return this;const t=h.bo.copyToDevice(this.basic,"GPU:0");return new l(t)}cpu(){if("CPU:0"===this.device)return this;const t=h.bo.copyToDevice(this.basic,"CPU:0");return new l(t)}cast(t){return c.cast(this,t)}add(t){return c.add(this,this.colocate(t))}sub(t){return c.sub(this,this.colocate(t))}mul(t){return c.mul(this,this.colocate(t))}div(t){return c.div(this,this.colocate(t))}matmul(t){return c.matmul(this,this.colocate(t))}onesLike(){const t=h.bo.onesLike(this.basic);return new l(t)}zerosLike(){const t=h.bo.zerosLike(this.basic);return new l(t)}neg(){return c.neg(this)}exp(){return c.exp(this)}log(){return c.log(this)}square(){return c.square(this)}sinh(){return c.sinh(this)}cosh(){return c.cosh(this)}tanh(){return c.tanh(this)}relu(){return c.relu(this)}sigmoid(){return c.sigmoid(this)}abs(){return c.abs(this)}transpose(t){return void 0===t&&(t=a.range(this.rank).reverse()),t=this.colocate(t,"int32"),c.transpose(this,t)}reverse(t){t||(t=[-1]);const e=new Uint8Array(this.rank);for(const s of t){u.assert(-this.rank<=s&&s<this.rank);e[s>=0?s:this.rank+s]=1}const s=this.colocate(e,"bool");return c.reverse(this,s)}argmax(t){return void 0===t&&(t=0),c.argmax(this,t)}argmin(t){return void 0===t&&(t=0),c.argmin(this,t)}reduceSum(t,s=!1){return t||(t=e(this.rank)),c.reduceSum(this,t,s)}reduceMean(t,s=!1){return t||(t=e(this.rank)),c.reduceMean(this,t,s)}reduceMax(t,s=!1){return t||(t=e(this.rank)),c.reduceMax(this,t,s)}reduceLogSumExp(t,s=!1){return t||(t=e(this.rank)),c.reduceLogSumExp(this,t,s)}equal(t){return c.equal(this,this.colocate(t))}greater(t){return c.greater(this,this.colocate(t,this.dtype))}greaterEqual(t){return c.greaterEqual(this,this.colocate(t,this.dtype))}less(t){return c.less(this,this.colocate(t,this.dtype))}lessEqual(t){return c.lessEqual(this,this.colocate(t,this.dtype))}select(t,e){const s=this.colocate(t),r=this.colocate(e,s.dtype);return c.select(this,s,r)}sign(){return c.sign(this)}slice(t,e){return u.assert(u.allFinite(t)),u.assert(u.allFinite(e)),c.slice(this,t,e)}reshape(t){return c.reshape(this,t)}flatten(){return this.reshape([-1])}squeeze(){const t=this.shape.filter(t=>t>1);return this.reshape(t)}softmax(t=-1){return s(this,t,c.softmax)}logSoftmax(t=-1){return s(this,t,c.logSoftmax)}dot(t){const e=this.colocate(t);let s,r,i,n;if(0===this.rank?(s=this.reshape([1,1]),i=[]):1===this.rank?(u.assert(this.shape[0]===e.shape[0]),s=this.reshape([1,this.shape[0]]),i=[]):2===this.rank?(s=this,i=[this.shape[0]]):s=null,0===e.rank?(r=e.reshape([1,1]),n=[]):1===e.rank?(u.assert(this.shape[this.rank-1]===e.shape[0]),r=e.reshape([e.shape[0],1]),n=[]):2===e.rank?(r=e,n=[e.shape[e.rank-1]]):r=null,!s||!r)throw new Error("dot with tensors of rank greater than 2 is not yet implemented.");const a=i.concat(n);return s.matmul(r).reshape(a)}oneHot(t,e=1,s=0){if("float32"===this.dtype)throw new Error("Must use integer type with oneHot.");return c.oneHot(this,t,e,s)}softmaxCE(t){const e=this.colocate(t).cast("float32");u.assert(2===e.rank),u.assert(2===this.rank);const s=this.logSoftmax();return e.mul(s).reduceSum([1]).neg()}setDiag(t){return c.setDiag(this,this.colocate(t,this.dtype))}}l.nextId=1,exports.Tensor=l,exports.gc=r;class p{constructor(){this.keeping=new Set,this.tensors=new Set}track(t){this.tensors.add(t)}untrack(t){this.tensors.delete(t),this.keeping.delete(t)}keep(t){this.keeping.add(t)}clean(){this.tensors.forEach(t=>{this.keeping.has(t)||null==t.basic||t.dispose()}),this.tensors.clear(),this.keeping.clear()}}const d=[];
},{"./api":1,"./backend":7,"./format":11,"./ops":4,"./util":2}],14:[function(require,module,exports) {
module.exports=function(o){return o&&"object"==typeof o&&"function"==typeof o.copy&&"function"==typeof o.fill&&"function"==typeof o.readUInt8};
},{}],23:[function(require,module,exports) {
"function"==typeof Object.create?module.exports=function(t,e){t.super_=e,t.prototype=Object.create(e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}})}:module.exports=function(t,e){t.super_=e;var o=function(){};o.prototype=e.prototype,t.prototype=new o,t.prototype.constructor=t};
},{}],10:[function(require,module,exports) {

function t(){throw new Error("setTimeout has not been defined")}function e(){throw new Error("clearTimeout has not been defined")}function n(e){if(s===setTimeout)return setTimeout(e,0);if((s===t||!s)&&setTimeout)return s=setTimeout,setTimeout(e,0);try{return s(e,0)}catch(t){try{return s.call(null,e,0)}catch(t){return s.call(this,e,0)}}}function r(t){if(l===clearTimeout)return clearTimeout(t);if((l===e||!l)&&clearTimeout)return l=clearTimeout,clearTimeout(t);try{return l(t)}catch(e){try{return l.call(null,t)}catch(e){return l.call(this,t)}}}function o(){m&&f&&(m=!1,f.length?h=f.concat(h):p=-1,h.length&&i())}function i(){if(!m){var t=n(o);m=!0;for(var e=h.length;e;){for(f=h,h=[];++p<e;)f&&f[p].run();p=-1,e=h.length}f=null,m=!1,r(t)}}function u(t,e){this.fun=t,this.array=e}function c(){}var s,l,a=module.exports={};!function(){try{s="function"==typeof setTimeout?setTimeout:t}catch(e){s=t}try{l="function"==typeof clearTimeout?clearTimeout:e}catch(t){l=e}}();var f,h=[],m=!1,p=-1;a.nextTick=function(t){var e=new Array(arguments.length-1);if(arguments.length>1)for(var r=1;r<arguments.length;r++)e[r-1]=arguments[r];h.push(new u(t,e)),1!==h.length||m||n(i)},u.prototype.run=function(){this.fun.apply(null,this.array)},a.title="browser",a.browser=!0,a.env={},a.argv=[],a.version="",a.versions={},a.on=c,a.addListener=c,a.once=c,a.off=c,a.removeListener=c,a.removeAllListeners=c,a.emit=c,a.prependListener=c,a.prependOnceListener=c,a.listeners=function(t){return[]},a.binding=function(t){throw new Error("process.binding is not supported")},a.cwd=function(){return"/"},a.chdir=function(t){throw new Error("process.chdir is not supported")},a.umask=function(){return 0};
},{}],9:[function(require,module,exports) {
var global = (1,eval)("this");
var process = require("process");
function e(e,n){var i={seen:[],stylize:r};return arguments.length>=3&&(i.depth=arguments[2]),arguments.length>=4&&(i.colors=arguments[3]),a(n)?i.showHidden=n:n&&exports._extend(i,n),h(i.showHidden)&&(i.showHidden=!1),h(i.depth)&&(i.depth=2),h(i.colors)&&(i.colors=!1),h(i.customInspect)&&(i.customInspect=!0),i.colors&&(i.stylize=t),o(i,e,i.depth)}function t(t,r){var n=e.styles[r];return n?"["+e.colors[n][0]+"m"+t+"["+e.colors[n][1]+"m":t}function r(e,t){return e}function n(e){var t={};return e.forEach(function(e,r){t[e]=!0}),t}function o(e,t,r){if(e.customInspect&&t&&j(t.inspect)&&t.inspect!==exports.inspect&&(!t.constructor||t.constructor.prototype!==t)){var a=t.inspect(r,e);return d(a)||(a=o(e,a,r)),a}var f=i(e,t);if(f)return f;var g=Object.keys(t),y=n(g);if(e.showHidden&&(g=Object.getOwnPropertyNames(t)),S(t)&&(g.indexOf("message")>=0||g.indexOf("description")>=0))return s(t);if(0===g.length){if(j(t)){var x=t.name?": "+t.name:"";return e.stylize("[Function"+x+"]","special")}if(b(t))return e.stylize(RegExp.prototype.toString.call(t),"regexp");if(v(t))return e.stylize(Date.prototype.toString.call(t),"date");if(S(t))return s(t)}var h="",m=!1,O=["{","}"];if(p(t)&&(m=!0,O=["[","]"]),j(t)){h=" [Function"+(t.name?": "+t.name:"")+"]"}if(b(t)&&(h=" "+RegExp.prototype.toString.call(t)),v(t)&&(h=" "+Date.prototype.toUTCString.call(t)),S(t)&&(h=" "+s(t)),0===g.length&&(!m||0==t.length))return O[0]+h+O[1];if(r<0)return b(t)?e.stylize(RegExp.prototype.toString.call(t),"regexp"):e.stylize("[Object]","special");e.seen.push(t);var z;return z=m?u(e,t,r,y,g):g.map(function(n){return c(e,t,r,y,n,m)}),e.seen.pop(),l(z,h,O)}function i(e,t){if(h(t))return e.stylize("undefined","undefined");if(d(t)){var r="'"+JSON.stringify(t).replace(/^"|"$/g,"").replace(/'/g,"\\'").replace(/\\"/g,'"')+"'";return e.stylize(r,"string")}return y(t)?e.stylize(""+t,"number"):a(t)?e.stylize(""+t,"boolean"):f(t)?e.stylize("null","null"):void 0}function s(e){return"["+Error.prototype.toString.call(e)+"]"}function u(e,t,r,n,o){for(var i=[],s=0,u=t.length;s<u;++s)D(t,String(s))?i.push(c(e,t,r,n,String(s),!0)):i.push("");return o.forEach(function(o){o.match(/^\d+$/)||i.push(c(e,t,r,n,o,!0))}),i}function c(e,t,r,n,i,s){var u,c,l;if((l=Object.getOwnPropertyDescriptor(t,i)||{value:t[i]}).get?c=l.set?e.stylize("[Getter/Setter]","special"):e.stylize("[Getter]","special"):l.set&&(c=e.stylize("[Setter]","special")),D(n,i)||(u="["+i+"]"),c||(e.seen.indexOf(l.value)<0?(c=f(r)?o(e,l.value,null):o(e,l.value,r-1)).indexOf("\n")>-1&&(c=s?c.split("\n").map(function(e){return"  "+e}).join("\n").substr(2):"\n"+c.split("\n").map(function(e){return"   "+e}).join("\n")):c=e.stylize("[Circular]","special")),h(u)){if(s&&i.match(/^\d+$/))return c;(u=JSON.stringify(""+i)).match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)?(u=u.substr(1,u.length-2),u=e.stylize(u,"name")):(u=u.replace(/'/g,"\\'").replace(/\\"/g,'"').replace(/(^"|"$)/g,"'"),u=e.stylize(u,"string"))}return u+": "+c}function l(e,t,r){return e.reduce(function(e,t){return 0,t.indexOf("\n")>=0&&0,e+t.replace(/\u001b\[\d\d?m/g,"").length+1},0)>60?r[0]+(""===t?"":t+"\n ")+" "+e.join(",\n  ")+" "+r[1]:r[0]+t+" "+e.join(", ")+" "+r[1]}function p(e){return Array.isArray(e)}function a(e){return"boolean"==typeof e}function f(e){return null===e}function g(e){return null==e}function y(e){return"number"==typeof e}function d(e){return"string"==typeof e}function x(e){return"symbol"==typeof e}function h(e){return void 0===e}function b(e){return m(e)&&"[object RegExp]"===z(e)}function m(e){return"object"==typeof e&&null!==e}function v(e){return m(e)&&"[object Date]"===z(e)}function S(e){return m(e)&&("[object Error]"===z(e)||e instanceof Error)}function j(e){return"function"==typeof e}function O(e){return null===e||"boolean"==typeof e||"number"==typeof e||"string"==typeof e||"symbol"==typeof e||void 0===e}function z(e){return Object.prototype.toString.call(e)}function w(e){return e<10?"0"+e.toString(10):e.toString(10)}function E(){var e=new Date,t=[w(e.getHours()),w(e.getMinutes()),w(e.getSeconds())].join(":");return[e.getDate(),$[e.getMonth()],t].join(" ")}function D(e,t){return Object.prototype.hasOwnProperty.call(e,t)}var N=(0,eval)("this"),A=require("process"),J=/%[sdj%]/g;exports.format=function(t){if(!d(t)){for(var r=[],n=0;n<arguments.length;n++)r.push(e(arguments[n]));return r.join(" ")}n=1;for(var o=arguments,i=o.length,s=String(t).replace(J,function(e){if("%%"===e)return"%";if(n>=i)return e;switch(e){case"%s":return String(o[n++]);case"%d":return Number(o[n++]);case"%j":try{return JSON.stringify(o[n++])}catch(e){return"[Circular]"}default:return e}}),u=o[n];n<i;u=o[++n])f(u)||!m(u)?s+=" "+u:s+=" "+e(u);return s},exports.deprecate=function(e,t){if(h(N.process))return function(){return exports.deprecate(e,t).apply(this,arguments)};if(!0===A.noDeprecation)return e;var r=!1;return function(){if(!r){if(A.throwDeprecation)throw new Error(t);A.traceDeprecation?console.trace(t):console.error(t),r=!0}return e.apply(this,arguments)}};var R,H={};exports.debuglog=function(e){if(h(R)&&(R=""),e=e.toUpperCase(),!H[e])if(new RegExp("\\b"+e+"\\b","i").test(R)){var t=A.pid;H[e]=function(){var r=exports.format.apply(exports,arguments);console.error("%s %d: %s",e,t,r)}}else H[e]=function(){};return H[e]},exports.inspect=e,e.colors={bold:[1,22],italic:[3,23],underline:[4,24],inverse:[7,27],white:[37,39],grey:[90,39],black:[30,39],blue:[34,39],cyan:[36,39],green:[32,39],magenta:[35,39],red:[31,39],yellow:[33,39]},e.styles={special:"cyan",number:"yellow",boolean:"yellow",undefined:"grey",null:"bold",string:"green",date:"magenta",regexp:"red"},exports.isArray=p,exports.isBoolean=a,exports.isNull=f,exports.isNullOrUndefined=g,exports.isNumber=y,exports.isString=d,exports.isSymbol=x,exports.isUndefined=h,exports.isRegExp=b,exports.isObject=m,exports.isDate=v,exports.isError=S,exports.isFunction=j,exports.isPrimitive=O,exports.isBuffer=require("./support/isBuffer");var $=["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"];exports.log=function(){console.log("%s - %s",E(),exports.format.apply(exports,arguments))},exports.inherits=require("inherits"),exports._extend=function(e,t){if(!t||!m(t))return e;for(var r=Object.keys(t),n=r.length;n--;)e[r[n]]=t[r[n]];return e};
},{"./support/isBuffer":14,"inherits":23,"process":10}],2:[function(require,module,exports) {
var process = require("process");
function t(t){for(const e of t)if(Number.isNaN(e))return!1;return!0}function e(t){if(t.cpu&&(t=t.cpu()),t.getData)return t=t,[t.shape,t.getData()];if(w.isTypedArray(t))return[[t.length],t];if(t instanceof Array)return[g(t),x(t)];if("number"==typeof t)return[[],[t]];throw new Error("Not TensorLike")}function r(t){const r=e(t)[1];if(1!==r.length)throw new Error("Not Scalar");return r[0]}function n(...t){A&&console.log.apply(null,t)}function o(t,e){if(t.length!==e.length)return!1;for(let r=0;r<t.length;++r)if(t[r]!==e[r])return!1;return!0}function s(t,e=""){if(!t)throw new Error(e)}function i(t,e=""){s(!t,e)}function a(t,e,n=.001){t=r(t),e=r(e),s(Math.abs(t-e)<n,`actual: ${t} expected: ${e}`)}function u(t,e,n=null){t=r(t),n||(n=`actual: ${t} expected: ${e}`),s(t===e,n)}function c(t,e){const r=`Shape mismatch. actual: ${E(t)} expected ${E(e)}`;s(o(t,e),r)}function l(t,r){const[n,o]=e(t),[i,a]=e(r);c(n,i);for(let t=0;t<o.length;t++)s(o[t]===a[t],`index ${t} actual: ${o[t]} expected: ${a[t]}`)}function p(t,r,n=.001){const[o,i]=e(t),[a,u]=e(r);c(o,a);for(let t=0;t<i.length;++t){const e=i[t],r=u[t];s(Math.abs(e-r)<n,`index ${t} actual: ${i[t]} expected: ${u[t]}`)}}function f(t){const e=[];for(let r=0;r<t.length;r++){const n=t[r];e[r]=Array.isArray(n)?f(n):n}return e}function h(t,e){const r=[],n=[],o=Math.max(t.length,e.length);for(let i=0;i<o;++i){const a=o-i-1;if(i>=t.length){r.unshift(a);continue}if(i>=e.length){n.unshift(a);continue}const u=t[t.length-i-1],c=e[e.length-i-1];u!==c&&(1===u&&1!==c?r.unshift(a):1!==u&&1===c?n.unshift(a):s(1===u&&1===c,"Incompatible broadcast shapes."))}return[r,n]}function x(t,e=[]){if(Array.isArray(t))for(let r=0;r<t.length;++r)x(t[r],e);else e.push(t);return e}function g(t){const e=[];for(;t instanceof Array;)e.push(t.length),t=t[0];return e}function d(t){return new Promise(function(e){setTimeout(e,t)})}var y=require("process");Object.defineProperty(exports,"__esModule",{value:!0});const m=require("./tensor"),w=require("./types"),A=!1,E=JSON.stringify,$=eval;if(exports.IS_WEB="undefined"!=typeof window,exports.IS_NODE=!exports.IS_WEB,exports.global=$(exports.IS_WEB?"window":"global"),exports.IS_NODE){const t=require("util").inspect.custom;m.Tensor.prototype[t]=function(t,e){return this.toString()},y.on("unhandledRejection",t=>{throw t})}exports.allFinite=t,exports.log=n,exports.shapesEqual=o,exports.assert=s,exports.assertFalse=i,exports.assertClose=a,exports.assertEqual=u,exports.assertShapesEqual=c,exports.assertAllEqual=l,exports.assertAllClose=p;class S{constructor(){this.map=new Map}get(t){return this.map.has(t)?this.map.get(t):0}keys(){return Array.from(this.map.keys())}inc(t){this.map.set(t,this.get(t)+1)}dec(t){this.map.set(t,this.get(t)-1)}}exports.CounterMap=S,exports.deepCloneArray=f,exports.bcastGradientArgs=h,exports.flatten=x,exports.inferShape=g,exports.delay=d;
},{"./tensor":6,"./types":8,"util":9,"process":10}],12:[function(require,module,exports) {
"use strict";function a(a){return m.assert(o.has(a)),o.get(a)}function t(a){switch(a){case"int32":case"float32":case"bool":return a;case"uint8":return"int32"}}Object.defineProperty(exports,"__esModule",{value:!0}),require("./dl/math/backends/backend_cpu"),require("./dl/math/backends/backend_webgl");const r=require("./dl/environment"),e=require("./dl/math/math"),n=require("./dl/math/ndarray"),s=require("./dl/math/types"),h=require("./types"),m=require("./util"),o=new Map,d=new e.NDArrayMath("cpu");r.ENV.setMath(d),o.set("CPU:0",d);let u;const c=r.ENV.getBackend("webgl");c&&(u=new e.NDArrayMath("webgl"),o.set("GPU:0",u));class y{static fromTypedArray(t,r,e,s){null==e&&(e=h.getDType(t)),null==s&&(s="CPU:0");const m=a(s),o=n.NDArray.make(r,{values:t},e,m);return new y(o,m)}constructor(a,t=d){this.dtype=a.dtype,this.shape=a.shape,this.math=t,this.ndarray=a,this.isDisposed=!1,m.assert(!1===this.ndarray.isDisposed)}getData(){return m.assert(!this.isDisposed),this.ndarray.getValues()}dispose(){m.assert(!this.isDisposed),this.ndarray.isDisposed||this.ndarray.dispose(),this.isDisposed=!0}}exports.TensorDL=y;class i{copyToDevice(t,r){const e=a(r),s=t.ndarray,h=n.NDArray.make(s.shape,{values:s.dataSync()},s.dtype,e);return new y(h,e)}getDevice(a){if(a.math===d)return"CPU:0";if(a.math===u)return"GPU:0";throw new Error("Unreachable")}listDevices(){const a=["CPU:0"];return c&&a.push("GPU:0"),a}add(a,t){r.ENV.setMath(a.math);const e=a.math.add(a.ndarray,t.ndarray);return new y(e,a.math)}sub(a,t){r.ENV.setMath(a.math);const e=a.math.sub(a.ndarray,t.ndarray);return new y(e,a.math)}mul(a,t){r.ENV.setMath(a.math);const e=a.math.multiply(a.ndarray,t.ndarray);return new y(e,a.math)}div(a,t){r.ENV.setMath(a.math);const e=a.math.divide(a.ndarray,t.ndarray);return new y(e,a.math)}neg(a){r.ENV.setMath(a.math);const t=a.math.neg(a.ndarray);return new y(t,a.math)}exp(a){r.ENV.setMath(a.math);const t=a.math.exp(a.ndarray);return new y(t,a.math)}log(a){r.ENV.setMath(a.math);const t=a.math.log(a.ndarray);return new y(t,a.math)}matmul(a,t,e=!1,n=!1){r.ENV.setMath(a.math);const h=a=>a?s.MatrixOrientation.TRANSPOSED:s.MatrixOrientation.REGULAR;m.assert(2===a.shape.length&&2===t.shape.length);const o=a.ndarray,d=t.ndarray,u=a.math.matMul(o,d,h(e),h(n));return new y(u,a.math)}setDiag(a,t){if(2!==a.shape.length||1!==t.shape.length)throw new Error("Not implemented");r.ENV.setMath(d);const e=d.setDiag(a.ndarray,t.ndarray);return new y(e,a.math)}onesLike(a){r.ENV.setMath(a.math);const t=n.NDArray.zerosLike(a.ndarray);return t.fill(1),new y(t,a.math)}zerosLike(a){r.ENV.setMath(a.math);const t=n.NDArray.zerosLike(a.ndarray);return new y(t,a.math)}fill(a,t){if(0!==a.shape.length)throw new Error("Fill value must be a scalar.");r.ENV.setMath(a.math);const e=n.NDArray.zeros(t,a.ndarray.dtype);return e.fill(a.ndarray.getValues()[0]),new y(e,a.math)}square(a){r.ENV.setMath(a.math);const t=a.math.square(a.ndarray);return new y(t,a.math)}sinh(a){r.ENV.setMath(a.math);const t=a.math.sinh(a.ndarray);return new y(t,a.math)}cosh(a){r.ENV.setMath(a.math);const t=a.math.cosh(a.ndarray);return new y(t,a.math)}tanh(a){r.ENV.setMath(a.math);const t=a.math.tanh(a.ndarray);return new y(t,a.math)}relu(a){r.ENV.setMath(a.math);const t=a.math.relu(a.ndarray);return new y(t,a.math)}reluGrad(a,t){const r=a.math,e=r.step(t.ndarray),n=r.multiply(a.ndarray,e);return new y(n,r)}sigmoid(a){r.ENV.setMath(a.math);const t=a.math.sigmoid(a.ndarray);return new y(t,a.math)}abs(a){r.ENV.setMath(a.math);const t=a.math.abs(a.ndarray);return new y(t,a.math)}randn(a,t){r.ENV.setMath(d);const e=n.NDArray.randNormal(a,0,1,"float32",t);return new y(e,d)}linspace(a,t,r){const e=(t-a)/(r-1),n=new Float32Array(r);for(let t=0;t<=r-1;++t)n[t]=a+t*e;return y.fromTypedArray(n,[r])}range(a,t,r){const e=(t-a)/r,n=new Int32Array(e);for(let t=0;t<e;++t)n[t]=a+t*r;return y.fromTypedArray(n,[e])}transpose(a,t){const r=Array.from(t.ndarray.getValues()),e=a.math.transpose(a.ndarray,r);return new y(e,a.math)}reverse(a,r){const e=a.ndarray,s=r.getData(),m=h.makeTypedArray(e.size,a.dtype),o=e.getValues(),d=t(a.dtype),u=n.NDArray.make(e.shape,{values:m},d);for(let a=0;a<e.size;++a){const t=e.indexToLoc(a),r=new Array(t.length);for(let a=0;a<r.length;a++)r[a]=s[a]?e.shape[a]-t[a]-1:t[a];m[u.locToIndex(r)]=o[a]}return new y(u,a.math)}argmax(a,t){r.ENV.setMath(a.math);const e=a.math.argMax(a.ndarray,t);return new y(e,a.math)}argmin(a,t){r.ENV.setMath(a.math);const e=a.math.argMin(a.ndarray,t);return new y(e,a.math)}reduceSum(a,t,e){r.ENV.setMath(a.math);const n=a.math.sum(a.ndarray,t,e);return new y(n,a.math)}reduceMean(a,t,e){r.ENV.setMath(a.math);const n=a.math.mean(a.ndarray,t,e);return new y(n,a.math)}reduceMax(a,t,e){r.ENV.setMath(a.math);const n=a.math.max(a.ndarray,t,e);return new y(n,a.math)}equal(a,t){r.ENV.setMath(a.math);const e=a.math.equal(a.ndarray,t.ndarray);return new y(e,a.math)}greater(a,t){r.ENV.setMath(a.math);const e=a.math.greater(a.ndarray,t.ndarray);return new y(e,a.math)}greaterEqual(a,t){r.ENV.setMath(a.math);const e=a.math.greaterEqual(a.ndarray,t.ndarray);return new y(e,a.math)}less(a,t){r.ENV.setMath(a.math);const e=a.math.less(a.ndarray,t.ndarray);return new y(e,a.math)}lessEqual(a,t){r.ENV.setMath(a.math);const e=a.math.lessEqual(a.ndarray,t.ndarray);return new y(e,a.math)}select(a,t,e){const n=t.math;r.ENV.setMath(n);const s=n.cast(a.ndarray,"bool"),h=n.select(s,t.ndarray,e.ndarray);return new y(h,n)}sign(a){r.ENV.setMath(a.math);const e=a.math,s=e.step(a.ndarray),h=t(a.dtype),m=n.Scalar.new(2,h),o=n.Scalar.new(1,h),d=e.scalarTimesArray(m,s),u=e.arrayMinusScalar(d,o);return new y(u,e)}slice(a,t,e){r.ENV.setMath(a.math);let n;switch(e=e.map((t,r)=>t>=0?t:(m.assert(-1===t,"Bad value in size"),a.shape[r])),a.shape.length){case 0:throw new Error("Slicing a scalar.");case 1:n=a.math.slice1D(a.ndarray.as1D(),t[0],e[0]);break;case 2:n=a.math.slice2D(a.ndarray,[t[0],t[1]],[e[0],e[1]]);break;case 3:n=a.math.slice3D(a.ndarray,[t[0],t[1],t[2]],[e[0],e[1],e[2]]);break;case 4:n=a.math.slice4D(a.ndarray,[t[0],t[1],t[2],t[3]],[e[0],e[1],e[2],e[3]]);break;default:throw new Error("Slicing for tensors rank higher than 4 not yet supported.")}return n=n.asType(a.dtype),new y(n,a.math)}reshape(a,t){r.ENV.setMath(a.math);const e=a.ndarray.reshape(t);return new y(e,a.math)}softmax(a){r.ENV.setMath(a.math);const t=a.math.softmax(a.ndarray);return new y(t,a.math)}logSoftmax(a){r.ENV.setMath(a.math);const t=a.ndarray,e=a.shape.length-1,n=a.math.sub(t,a.math.logSumExp(t,e,!0));return new y(n,a.math)}cast(a,e){r.ENV.setMath(a.math);const n=a.math.cast(a.ndarray,t(e));return new y(n,a.math)}oneHot(a,t,e,n){r.ENV.setMath(a.math);const s=a.math.cast(a.ndarray,"float32").as1D(),h=a.math.oneHot(s,t,e,n);return new y(h,a.math)}}exports.OpsDL=i;
},{"./dl/math/backends/backend_cpu":20,"./dl/math/backends/backend_webgl":21,"./dl/environment":15,"./dl/math/math":18,"./dl/math/ndarray":17,"./dl/math/types":19,"./types":8,"./util":2}],16:[function(require,module,exports) {
module.exports=function(){const n=["./tensorflow-binding.node","./build/Release/tensorflow-binding.node","./build/Debug/tensorflow-binding.node","../build/Release/tensorflow-binding.node","../build/Debug/tensorflow-binding.node","propel_linux_gpu","propel_linux","propel_mac","propel_windows"];for(const e of n)try{return require(e)}catch(n){if("MODULE_NOT_FOUND"!==n.code)throw n}return null}();
},{}],13:[function(require,module,exports) {
"use strict";function e(){return exports.binding=require("./load_binding"),!!exports.binding&&(exports.ctx=new exports.binding.Context,!0)}function n(e,n,t){const r=n.map(e=>e.handle),i=exports.binding.execute(exports.ctx,e,t,r);return a.assertEqual(i.length,1),new x(i[0])}function t(e,n,t){const r=n.map(e=>e.handle),s=null==t?exports.binding.getDType(r[0]):i(t),o=[["T",exports.binding.ATTR_TYPE,s]],T=exports.binding.execute(exports.ctx,e,o,r);return new x(T[0])}function r(e){switch(e){case exports.binding.TF_BOOL:return"bool";case exports.binding.TF_FLOAT:return"float32";case exports.binding.TF_INT32:return"int32";case exports.binding.TF_UINT8:return"uint8";default:throw new Error(`Not Implemented: dtype ${e}`)}}function i(e){switch(e){case"bool":return exports.binding.TF_BOOL;case"float32":return exports.binding.TF_FLOAT;case"int32":return exports.binding.TF_INT32;case"uint8":return exports.binding.TF_UINT8;default:throw new Error(`Not Implemented ${e}`)}}function s(e){return e?exports.binding.getDevice(e.handle):"CPU:0"}function o(e,n){return new x(exports.binding.createSmallHandle(exports.ctx,exports.binding.TF_INT32,s(n),e))}function T(e,n){return new x(exports.binding.createSmallHandle(exports.ctx,exports.binding.TF_FLOAT,s(n),e))}function d(e){return e.split("/").pop().replace("device:","")}Object.defineProperty(exports,"__esModule",{value:!0});const p=require("./types"),a=require("./util");exports.loadBinding=e,exports.execute0=n,exports.execute1=t;class x{static fromTypedArray(e,n,t,r){null==t&&(t=p.getDType(e));const s=i(t);let o=new exports.binding.Handle(e,n,s);return r&&"CPU:0"!==r&&(o=exports.binding.copyToDevice(exports.ctx,o,r)),new x(o)}constructor(e){this.handle=e}get shape(){return exports.binding.getShape(this.handle)}get dtype(){return r(exports.binding.getDType(this.handle))}get device(){return d(exports.binding.getDevice(this.handle))}getData(){if(!this.data){const e=exports.binding.asArrayBuffer(this.handle);switch(this.dtype){case"float32":this.data=new Float32Array(e);break;case"int32":this.data=new Int32Array(e);break;case"uint8":case"bool":this.data=new Uint8Array(e)}}return this.data}dispose(){a.assert(null!=this.handle),exports.binding.dispose(this.handle),this.handle=null}}exports.TensorTF=x;class g{copyToDevice(e,n){const t=exports.binding.copyToDevice(exports.ctx,e.handle,n);return new x(t)}getDevice(e){return e.device}listDevices(){return exports.binding.listDevices(exports.ctx).map(e=>d(e.name))}add(e,n){return t("Add",[e,n])}sub(e,n){return t("Sub",[e,n])}mul(e,n){return t("Mul",[e,n])}div(e,n){return t("Div",[e,n])}neg(e){return t("Neg",[e])}exp(e){return t("Exp",[e])}log(e){return t("Log",[e])}setDiag(e,n){return t("MatrixSetDiag",[e,n])}onesLike(e){return t("OnesLike",[e])}zerosLike(e){return t("ZerosLike",[e])}fill(e,n){if(0!==e.shape.length)throw new Error("Fill value must be a scalar.");return t("Fill",[o(n),e],e.dtype)}square(e){return t("Square",[e])}sinh(e){return t("Sinh",[e])}cosh(e){return t("Cosh",[e])}tanh(e){return t("Tanh",[e])}relu(e){return t("Relu",[e])}reluGrad(e,n){return t("ReluGrad",[e,n])}sigmoid(e){return t("Sigmoid",[e])}abs(e){return t("Abs",[e])}randn(e,t){const r=o(e);"number"!=typeof t&&(t=0);return n("RandomStandardNormal",[r],[["dtype",exports.binding.ATTR_TYPE,exports.binding.TF_FLOAT],["T",exports.binding.ATTR_TYPE,exports.binding.TF_INT32],["seed",exports.binding.ATTR_INT,t],["seed2",exports.binding.ATTR_INT,t]])}linspace(e,t,r){return n("LinSpace",[T(e),T(t),o(r)],[["T",exports.binding.ATTR_TYPE,exports.binding.TF_FLOAT],["Tidx",exports.binding.ATTR_TYPE,exports.binding.TF_INT32]])}range(e,t,r){return n("Range",[o(e),o(t),o(r)],[["Tidx",exports.binding.ATTR_TYPE,exports.binding.TF_INT32]])}transpose(e,t){return n("Transpose",[e,t],[["T",exports.binding.ATTR_TYPE,exports.binding.getDType(e.handle)],["Tperm",exports.binding.ATTR_TYPE,exports.binding.getDType(t.handle)]])}reverse(e,n){return a.assert("bool"===n.dtype),t("Reverse",[e,n])}matmul(e,t,r=!1,i=!1){return n("MatMul",[e,t],[["T",exports.binding.ATTR_TYPE,exports.binding.getDType(e.handle)],["transpose_a",exports.binding.ATTR_BOOL,r],["transpose_b",exports.binding.ATTR_BOOL,i]])}argmax(e,t){return n("ArgMax",[e,o(t)],[["T",exports.binding.ATTR_TYPE,exports.binding.getDType(e.handle)],["Tidx",exports.binding.ATTR_TYPE,exports.binding.TF_INT32],["output_type",exports.binding.ATTR_TYPE,exports.binding.TF_INT32]])}argmin(e,t){return n("ArgMin",[e,o(t)],[["T",exports.binding.ATTR_TYPE,exports.binding.getDType(e.handle)],["Tidx",exports.binding.ATTR_TYPE,exports.binding.TF_INT32],["output_type",exports.binding.ATTR_TYPE,exports.binding.TF_INT32]])}reduceSum(e,t,r){return n("Sum",[e,o(t)],[["T",exports.binding.ATTR_TYPE,exports.binding.getDType(e.handle)],["Tidx",exports.binding.ATTR_TYPE,exports.binding.TF_INT32],["keep_dims",exports.binding.ATTR_BOOL,r]])}reduceMean(e,t,r){return n("Mean",[e,o(t)],[["T",exports.binding.ATTR_TYPE,exports.binding.getDType(e.handle)],["Tidx",exports.binding.ATTR_TYPE,exports.binding.TF_INT32],["keep_dims",exports.binding.ATTR_BOOL,r]])}reduceMax(e,t,r){return n("Max",[e,o(t)],[["T",exports.binding.ATTR_TYPE,exports.binding.getDType(e.handle)],["Tidx",exports.binding.ATTR_TYPE,exports.binding.TF_INT32],["keep_dims",exports.binding.ATTR_BOOL,r]])}equal(e,n){return t("Equal",[e,n])}greater(e,n){return t("Greater",[e,n])}greaterEqual(e,n){return t("GreaterEqual",[e,n])}less(e,n){return t("Less",[e,n])}lessEqual(e,n){return t("LessEqual",[e,n])}select(e,n,r){return t("Select",[e,n,r],n.dtype)}sign(e){return t("Sign",[e])}slice(e,n,t){let r;"int32"!==e.dtype||exports.binding.getDevice(e.handle).endsWith("CPU:0")?r=e.handle:(console.warn("Slice on GPU not supported for int32. Copying to CPU."),r=exports.binding.copyToDevice(exports.ctx,e.handle,"CPU:0"));const i=o(n),s=o(t),T=[r,i.handle,s.handle],d=[["T",exports.binding.ATTR_TYPE,exports.binding.getDType(r)],["Index",exports.binding.ATTR_TYPE,exports.binding.TF_INT32]],p=exports.binding.execute(exports.ctx,"Slice",d,T);return a.assertEqual(p.length,1),new x(p[0])}reshape(e,n){let t;"int32"!==e.dtype||exports.binding.getDevice(e.handle).endsWith("CPU:0")?t=e.handle:(console.warn("Reshape on GPU not supported for int32. Copying to CPU."),t=exports.binding.copyToDevice(exports.ctx,e.handle,"CPU:0"));const r=[t,o(n).handle],i=[["T",exports.binding.ATTR_TYPE,exports.binding.getDType(t)],["Tshape",exports.binding.ATTR_TYPE,exports.binding.TF_INT32]],s=exports.binding.execute(exports.ctx,"Reshape",i,r);return a.assertEqual(s.length,1),new x(s[0])}softmax(e){return t("Softmax",[e])}logSoftmax(e){return t("LogSoftmax",[e])}cast(e,t){return n("Cast",[e],[["SrcT",exports.binding.ATTR_TYPE,exports.binding.getDType(e.handle)],["DstT",exports.binding.ATTR_TYPE,i(t)]])}oneHot(e,t,r,i){if("float32"===e.dtype)throw new Error("Must use integer type with oneHot.");const s=o(t),d=T(r,e);return n("OneHot",[e,s,d,T(i,e)],[["T",exports.binding.ATTR_TYPE,exports.binding.getDType(d.handle)],["TI",exports.binding.ATTR_TYPE,exports.binding.getDType(e.handle)],["axis",exports.binding.ATTR_INT,-1]])}}exports.OpsTF=g;
},{"./types":8,"./util":2,"./load_binding":16}],7:[function(require,module,exports) {
"use strict";function e(){return!a.IS_WEB}function r(e,r){const n=s.fromTypedArray,o=r?r.dtype:void 0,i=(r?r.device:null)||"CPU:0";if("number"==typeof e)return n(t.makeTypedArray([e],o),[],o,i);if(t.isTypedArray(e))return n(e,[e.length],o,i);if(Array.isArray(e)){e instanceof Array||(e=a.deepCloneArray(e));const r=a.inferShape(e),s=a.flatten(e);return n(t.makeTypedArray(s,o),r,o,i)}throw new Error("Unreachable")}Object.defineProperty(exports,"__esModule",{value:!0});const n=require("./dl"),o=require("./tf"),t=require("./types"),a=require("./util");let s,i=!1;i?console.warn("Warning: backend.onLoad called more than once."):(i=!0,e()&&o.loadBinding()?(console.log("Using TF backend."),s=o.TensorTF,exports.bo=new o.OpsTF,exports.backend="tf"):(console.log("Using DL backend."),s=n.TensorDL,exports.bo=new n.OpsDL,exports.backend="dl")),exports.convertBasic=r;
},{"./dl":12,"./tf":13,"./types":8,"./util":2}],25:[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var e=exports.name="d3",d=exports.version="4.13.0",s=exports.description="Data-Driven Documents",i=exports.keywords=["dom","visualization","svg","animation","canvas"],t=exports.homepage="https://d3js.org",o=exports.license="BSD-3-Clause",r=exports.author={name:"Mike Bostock",url:"https://bost.ocks.org/mike"},p=exports.main="build/d3.node.js",a=exports.unpkg="build/d3.min.js",l=exports.jsdelivr="build/d3.min.js",n="index";exports.module=n;var u=exports.repository={type:"git",url:"https://github.com/d3/d3.git"},m=exports.scripts={pretest:"rimraf build && mkdir build && json2module package.json > build/package.js && node rollup.node",test:"tape 'test/**/*-test.js'",prepublishOnly:'npm run test && rollup -c --banner "$(preamble)" && uglifyjs -b beautify=false,preamble="\'$(preamble)\'" build/d3.js -c negate_iife=false -m -o build/d3.min.js',postpublish:'git push && git push --tags && cd ../d3.github.com && git pull && cp ../d3/build/d3.js d3.v4.js && cp ../d3/build/d3.min.js d3.v4.min.js && git add d3.v4.js d3.v4.min.js && git commit -m "d3 ${npm_package_version}" && git push && cd - && cd ../d3-bower && git pull && cp ../d3/LICENSE ../d3/README.md ../d3/build/d3.js ../d3/build/d3.min.js . && git add -- LICENSE README.md d3.js d3.min.js && git commit -m "${npm_package_version}" && git tag -am "${npm_package_version}" v${npm_package_version} && git push && git push --tags && cd - && zip -j build/d3.zip -- LICENSE README.md API.md CHANGES.md build/d3.js build/d3.min.js'},c=exports.devDependencies={json2module:"0.0","package-preamble":"0.1",rimraf:"2",rollup:"0.53","rollup-plugin-ascii":"0.0","rollup-plugin-node-resolve":"3",tape:"4","uglify-js":"3.2"},g=exports.dependencies={"d3-array":"1.2.1","d3-axis":"1.0.8","d3-brush":"1.0.4","d3-chord":"1.0.4","d3-collection":"1.0.4","d3-color":"1.0.3","d3-dispatch":"1.0.3","d3-drag":"1.2.1","d3-dsv":"1.0.8","d3-ease":"1.0.3","d3-force":"1.1.0","d3-format":"1.2.2","d3-geo":"1.9.1","d3-hierarchy":"1.1.5","d3-interpolate":"1.1.6","d3-path":"1.0.5","d3-polygon":"1.0.3","d3-quadtree":"1.0.3","d3-queue":"3.0.7","d3-random":"1.1.0","d3-request":"1.0.6","d3-scale":"1.0.7","d3-selection":"1.3.0","d3-shape":"1.2.0","d3-time":"1.0.8","d3-time-format":"2.1.1","d3-timer":"1.0.7","d3-transition":"1.1.1","d3-voronoi":"1.1.2","d3-zoom":"1.7.1"};
},{}],99:[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=function(e,t){return e<t?-1:e>t?1:e>=t?0:NaN};
},{}],96:[function(require,module,exports) {
"use strict";function e(e){return e&&e.__esModule?e:{default:e}}function n(e){return function(n,t){return(0,r.default)(e(n),t)}}Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=function(e){return 1===e.length&&(e=n(e)),{left:function(n,t,r,u){for(null==r&&(r=0),null==u&&(u=n.length);r<u;){var l=r+u>>>1;e(n[l],t)<0?r=l+1:u=l}return r},right:function(n,t,r,u){for(null==r&&(r=0),null==u&&(u=n.length);r<u;){var l=r+u>>>1;e(n[l],t)>0?u=l:r=l+1}return r}}};var t=require("./ascending"),r=e(t);
},{"./ascending":99}],97:[function(require,module,exports) {
"use strict";function e(e){return e&&e.__esModule?e:{default:e}}Object.defineProperty(exports,"__esModule",{value:!0}),exports.bisectLeft=exports.bisectRight=void 0;var t=require("./ascending"),r=e(t),s=require("./bisector"),i=e(s),o=(0,i.default)(r.default),u=exports.bisectRight=o.right,c=exports.bisectLeft=o.left;exports.default=u;
},{"./ascending":99,"./bisector":96}],107:[function(require,module,exports) {
"use strict";function e(e,r){return[e,r]}Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=function(r,t){null==t&&(t=e);for(var n=0,u=r.length-1,o=r[0],l=new Array(u<0?0:u);n<u;)l[n]=t(o,o=r[++n]);return l},exports.pair=e;
},{}],100:[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=function(r,t,n){var u,a,l,o,i=r.length,s=t.length,f=new Array(i*s);for(null==n&&(n=e.pair),u=l=0;u<i;++u)for(o=r[u],a=0;a<s;++a,++l)f[l]=n(o,t[a]);return f};var e=require("./pairs");
},{"./pairs":107}],101:[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=function(e,t){return t<e?-1:t>e?1:t>=e?0:NaN};
},{}],364:[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=function(e){return null===e?NaN:+e};
},{}],115:[function(require,module,exports) {
"use strict";function e(e){return e&&e.__esModule?e:{default:e}}Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=function(e,r){var u,f,l=e.length,n=0,a=-1,i=0,o=0;if(null==r)for(;++a<l;)isNaN(u=(0,t.default)(e[a]))||(o+=(f=u-i)*(u-(i+=f/++n)));else for(;++a<l;)isNaN(u=(0,t.default)(r(e[a],a,e)))||(o+=(f=u-i)*(u-(i+=f/++n)));if(n>1)return o/(n-1)};var r=require("./number"),t=e(r);
},{"./number":364}],102:[function(require,module,exports) {
"use strict";function e(e){return e&&e.__esModule?e:{default:e}}Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=function(e,r){var u=(0,t.default)(e,r);return u?Math.sqrt(u):u};var r=require("./variance"),t=e(r);
},{"./variance":115}],98:[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=function(e,l){var r,u,f,n=e.length,t=-1;if(null==l){for(;++t<n;)if(null!=(r=e[t])&&r>=r)for(u=f=r;++t<n;)null!=(r=e[t])&&(u>r&&(u=r),f<r&&(f=r))}else for(;++t<n;)if(null!=(r=l(e[t],t,e))&&r>=r)for(u=f=r;++t<n;)null!=(r=l(e[t],t,e))&&(u>r&&(u=r),f<r&&(f=r));return[u,f]};
},{}],362:[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var e=Array.prototype,r=exports.slice=e.slice,t=exports.map=e.map;
},{}],361:[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=function(e){return function(){return e}};
},{}],363:[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=function(e){return e};
},{}],109:[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=function(e,t,r){e=+e,t=+t,r=(n=arguments.length)<2?(t=e,e=0,1):n<3?1:+r;for(var a=-1,n=0|Math.max(0,Math.ceil((t-e)/r)),o=new Array(n);++a<n;)o[a]=e+a*r;return o};
},{}],118:[function(require,module,exports) {
"use strict";function t(t,r,M){var h=(r-t)/Math.max(0,M),i=Math.floor(Math.log(h)/Math.LN10),n=h/Math.pow(10,i);return i>=0?(n>=a?10:n>=e?5:n>=o?2:1)*Math.pow(10,i):-Math.pow(10,-i)/(n>=a?10:n>=e?5:n>=o?2:1)}function r(t,r,M){var h=Math.abs(r-t)/Math.max(0,M),i=Math.pow(10,Math.floor(Math.log(h)/Math.LN10)),n=h/i;return n>=a?i*=10:n>=e?i*=5:n>=o&&(i*=2),r<t?-i:i}Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=function(r,a,e){var o,M,h,i,n=-1;if(a=+a,r=+r,e=+e,r===a&&e>0)return[r];if((o=a<r)&&(M=r,r=a,a=M),0===(i=t(r,a,e))||!isFinite(i))return[];if(i>0)for(r=Math.ceil(r/i),a=Math.floor(a/i),h=new Array(M=Math.ceil(a-r+1));++n<M;)h[n]=(r+n)*i;else for(r=Math.floor(r*i),a=Math.ceil(a*i),h=new Array(M=Math.ceil(r-a+1));++n<M;)h[n]=(r-n)/i;return o&&h.reverse(),h},exports.tickIncrement=t,exports.tickStep=r;var a=Math.sqrt(50),e=Math.sqrt(10),o=Math.sqrt(2);
},{}],239:[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=function(e){return Math.ceil(Math.log(e.length)/Math.LN2)+1};
},{}],104:[function(require,module,exports) {
"use strict";function e(e){return e&&e.__esModule?e:{default:e}}Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=function(){function e(e){var r,a,i=e.length,o=new Array(i);for(r=0;r<i;++r)o[r]=t(e[r],r,e);var l=n(o),s=l[0],h=l[1],y=f(o,s,h);Array.isArray(y)||(y=(0,d.tickStep)(s,h,y),y=(0,c.default)(Math.ceil(s/y)*y,Math.floor(h/y)*y,y));for(var p=y.length;y[0]<=s;)y.shift(),--p;for(;y[p-1]>h;)y.pop(),--p;var q,v=new Array(p+1);for(r=0;r<=p;++r)(q=v[r]=[]).x0=r>0?y[r-1]:s,q.x1=r<p?y[r]:h;for(r=0;r<i;++r)s<=(a=o[r])&&a<=h&&v[(0,u.default)(y,a,0,p)].push(e[r]);return v}var t=l.default,n=i.default,f=y.default;return e.value=function(r){return arguments.length?(t="function"==typeof r?r:(0,a.default)(r),e):t},e.domain=function(r){return arguments.length?(n="function"==typeof r?r:(0,a.default)([r[0],r[1]]),e):n},e.thresholds=function(t){return arguments.length?(f="function"==typeof t?t:Array.isArray(t)?(0,a.default)(r.slice.call(t)):(0,a.default)(t),e):f},e};var r=require("./array"),t=require("./bisect"),u=e(t),n=require("./constant"),a=e(n),f=require("./extent"),i=e(f),o=require("./identity"),l=e(o),s=require("./range"),c=e(s),d=require("./ticks"),h=require("./threshold/sturges"),y=e(h);
},{"./array":362,"./bisect":97,"./constant":361,"./extent":98,"./identity":363,"./range":109,"./ticks":118,"./threshold/sturges":239}],113:[function(require,module,exports) {
"use strict";function e(e){return e&&e.__esModule?e:{default:e}}Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=function(e,r,u){if(null==u&&(u=t.default),n=e.length){if((r=+r)<=0||n<2)return+u(e[0],0,e);if(r>=1)return+u(e[n-1],n-1,e);var n,f=(n-1)*r,l=Math.floor(f),o=+u(e[l],l,e);return o+(+u(e[l+1],l+1,e)-o)*(f-l)}};var r=require("./number"),t=e(r);
},{"./number":364}],236:[function(require,module,exports) {
"use strict";function e(e){return e&&e.__esModule?e:{default:e}}Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=function(e,t,a){return e=r.map.call(e,l.default).sort(u.default),Math.ceil((a-t)/(2*((0,i.default)(e,.75)-(0,i.default)(e,.25))*Math.pow(e.length,-1/3)))};var r=require("../array"),t=require("../ascending"),u=e(t),a=require("../number"),l=e(a),n=require("../quantile"),i=e(n);
},{"../array":362,"../ascending":99,"../number":364,"../quantile":113}],237:[function(require,module,exports) {
"use strict";function e(e){return e&&e.__esModule?e:{default:e}}Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=function(e,t,u){return Math.ceil((u-t)/(3.5*(0,r.default)(e)*Math.pow(e.length,-1/3)))};var t=require("../deviation"),r=e(t);
},{"../deviation":102}],108:[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=function(e,l){var r,u,f=e.length,n=-1;if(null==l){for(;++n<f;)if(null!=(r=e[n])&&r>=r)for(u=r;++n<f;)null!=(r=e[n])&&r>u&&(u=r)}else for(;++n<f;)if(null!=(r=l(e[n],n,e))&&r>=r)for(u=r;++n<f;)null!=(r=l(e[n],n,e))&&r>u&&(u=r);return u};
},{}],106:[function(require,module,exports) {
"use strict";function e(e){return e&&e.__esModule?e:{default:e}}Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=function(e,r){var u,f=e.length,l=f,n=-1,a=0;if(null==r)for(;++n<f;)isNaN(u=(0,t.default)(e[n]))?--l:a+=u;else for(;++n<f;)isNaN(u=(0,t.default)(r(e[n],n,e)))?--l:a+=u;if(l)return a/l};var r=require("./number"),t=e(r);
},{"./number":364}],103:[function(require,module,exports) {
"use strict";function e(e){return e&&e.__esModule?e:{default:e}}Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=function(e,u){var t,a=e.length,s=-1,f=[];if(null==u)for(;++s<a;)isNaN(t=(0,l.default)(e[s]))||f.push(t);else for(;++s<a;)isNaN(t=(0,l.default)(u(e[s],s,e)))||f.push(t);return(0,n.default)(f.sort(r.default),.5)};var u=require("./ascending"),r=e(u),t=require("./number"),l=e(t),a=require("./quantile"),n=e(a);
},{"./ascending":99,"./number":364,"./quantile":113}],105:[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=function(e){for(var r,t,n,o=e.length,f=-1,l=0;++f<o;)l+=e[f].length;for(t=new Array(l);--o>=0;)for(r=(n=e[o]).length;--r>=0;)t[--l]=n[r];return t};
},{}],110:[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=function(e,l){var r,u,f=e.length,n=-1;if(null==l){for(;++n<f;)if(null!=(r=e[n])&&r>=r)for(u=r;++n<f;)null!=(r=e[n])&&u>r&&(u=r)}else for(;++n<f;)if(null!=(r=l(e[n],n,e))&&r>=r)for(u=r;++n<f;)null!=(r=l(e[n],n,e))&&u>r&&(u=r);return u};
},{}],111:[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=function(e,r){for(var t=r.length,n=new Array(t);t--;)n[t]=e[r[t]];return n};
},{}],112:[function(require,module,exports) {
"use strict";function e(e){return e&&e.__esModule?e:{default:e}}Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=function(e,r){if(u=e.length){var u,n,l=0,o=0,d=e[o];for(null==r&&(r=t.default);++l<u;)(r(n=e[l],d)<0||0!==r(d,d))&&(d=n,o=l);return 0===r(d,d)?o:void 0}};var r=require("./ascending"),t=e(r);
},{"./ascending":99}],116:[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=function(e,t,r){for(var l,n,u=(null==r?e.length:r)-(t=null==t?0:+t);u;)n=Math.random()*u--|0,l=e[u+t],e[u+t]=e[n+t],e[n+t]=l;return e};
},{}],114:[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=function(e,r){var t,l=e.length,o=-1,u=0;if(null==r)for(;++o<l;)(t=+e[o])&&(u+=t);else for(;++o<l;)(t=+r(e[o],o,e))&&(u+=t);return u};
},{}],117:[function(require,module,exports) {
"use strict";function e(e){return e&&e.__esModule?e:{default:e}}function r(e){return e.length}Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=function(e){if(!(o=e.length))return[];for(var t=-1,u=(0,n.default)(e,r),f=new Array(u);++t<u;)for(var o,a=-1,i=f[t]=new Array(o);++a<o;)i[a]=e[a][t];return f};var t=require("./min"),n=e(t);
},{"./min":110}],120:[function(require,module,exports) {
"use strict";function e(e){return e&&e.__esModule?e:{default:e}}Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=function(){return(0,r.default)(arguments)};var t=require("./transpose"),r=e(t);
},{"./transpose":117}],66:[function(require,module,exports) {
"use strict";function e(e){return e&&e.__esModule?e:{default:e}}Object.defineProperty(exports,"__esModule",{value:!0});var r=require("./src/bisect");Object.defineProperty(exports,"bisect",{enumerable:!0,get:function(){return e(r).default}}),Object.defineProperty(exports,"bisectRight",{enumerable:!0,get:function(){return r.bisectRight}}),Object.defineProperty(exports,"bisectLeft",{enumerable:!0,get:function(){return r.bisectLeft}});var t=require("./src/ascending");Object.defineProperty(exports,"ascending",{enumerable:!0,get:function(){return e(t).default}});var n=require("./src/bisector");Object.defineProperty(exports,"bisector",{enumerable:!0,get:function(){return e(n).default}});var u=require("./src/cross");Object.defineProperty(exports,"cross",{enumerable:!0,get:function(){return e(u).default}});var i=require("./src/descending");Object.defineProperty(exports,"descending",{enumerable:!0,get:function(){return e(i).default}});var c=require("./src/deviation");Object.defineProperty(exports,"deviation",{enumerable:!0,get:function(){return e(c).default}});var o=require("./src/extent");Object.defineProperty(exports,"extent",{enumerable:!0,get:function(){return e(o).default}});var a=require("./src/histogram");Object.defineProperty(exports,"histogram",{enumerable:!0,get:function(){return e(a).default}});var s=require("./src/threshold/freedmanDiaconis");Object.defineProperty(exports,"thresholdFreedmanDiaconis",{enumerable:!0,get:function(){return e(s).default}});var f=require("./src/threshold/scott");Object.defineProperty(exports,"thresholdScott",{enumerable:!0,get:function(){return e(f).default}});var d=require("./src/threshold/sturges");Object.defineProperty(exports,"thresholdSturges",{enumerable:!0,get:function(){return e(d).default}});var p=require("./src/max");Object.defineProperty(exports,"max",{enumerable:!0,get:function(){return e(p).default}});var l=require("./src/mean");Object.defineProperty(exports,"mean",{enumerable:!0,get:function(){return e(l).default}});var b=require("./src/median");Object.defineProperty(exports,"median",{enumerable:!0,get:function(){return e(b).default}});var m=require("./src/merge");Object.defineProperty(exports,"merge",{enumerable:!0,get:function(){return e(m).default}});var g=require("./src/min");Object.defineProperty(exports,"min",{enumerable:!0,get:function(){return e(g).default}});var x=require("./src/pairs");Object.defineProperty(exports,"pairs",{enumerable:!0,get:function(){return e(x).default}});var j=require("./src/permute");Object.defineProperty(exports,"permute",{enumerable:!0,get:function(){return e(j).default}});var v=require("./src/quantile");Object.defineProperty(exports,"quantile",{enumerable:!0,get:function(){return e(v).default}});var y=require("./src/range");Object.defineProperty(exports,"range",{enumerable:!0,get:function(){return e(y).default}});var O=require("./src/scan");Object.defineProperty(exports,"scan",{enumerable:!0,get:function(){return e(O).default}});var P=require("./src/shuffle");Object.defineProperty(exports,"shuffle",{enumerable:!0,get:function(){return e(P).default}});var q=require("./src/sum");Object.defineProperty(exports,"sum",{enumerable:!0,get:function(){return e(q).default}});var h=require("./src/ticks");Object.defineProperty(exports,"ticks",{enumerable:!0,get:function(){return e(h).default}}),Object.defineProperty(exports,"tickIncrement",{enumerable:!0,get:function(){return h.tickIncrement}}),Object.defineProperty(exports,"tickStep",{enumerable:!0,get:function(){return h.tickStep}});var k=require("./src/transpose");Object.defineProperty(exports,"transpose",{enumerable:!0,get:function(){return e(k).default}});var S=require("./src/variance");Object.defineProperty(exports,"variance",{enumerable:!0,get:function(){return e(S).default}});var _=require("./src/zip");Object.defineProperty(exports,"zip",{enumerable:!0,get:function(){return e(_).default}});
},{"./src/bisect":97,"./src/ascending":99,"./src/bisector":96,"./src/cross":100,"./src/descending":101,"./src/deviation":102,"./src/extent":98,"./src/histogram":104,"./src/threshold/freedmanDiaconis":236,"./src/threshold/scott":237,"./src/threshold/sturges":239,"./src/max":108,"./src/mean":106,"./src/median":103,"./src/merge":105,"./src/min":110,"./src/pairs":107,"./src/permute":111,"./src/quantile":113,"./src/range":109,"./src/scan":112,"./src/shuffle":116,"./src/sum":114,"./src/ticks":118,"./src/transpose":117,"./src/variance":115,"./src/zip":120}],360:[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var e=exports.slice=Array.prototype.slice;
},{}],93:[function(require,module,exports) {
"use strict";function t(t){return t&&t.__esModule?t:{default:t}}function n(t){return"translate("+(t+.5)+",0)"}function r(t){return"translate(0,"+(t+.5)+")"}function e(t){return function(n){return+t(n)}}function i(t){var n=Math.max(0,t.bandwidth()-1)/2;return t.round()&&(n=Math.round(n)),function(r){return+t(r)+n}}function a(){return!this.__axis}function u(t,u){function o(n){var r=null==c?u.ticks?u.ticks.apply(u,l):u.domain():c,o=null==s?u.tickFormat?u.tickFormat.apply(u,l):m.default:s,f=Math.max(d,0)+_,b=u.range(),z=+b[0]+.5,A=+b[b.length-1]+.5,V=(u.bandwidth?i:e)(u.copy()),H=n.selection?n.selection():n,S=H.selectAll(".domain").data([null]),q=H.selectAll(".tick").data(r,u).order(),w=q.exit(),O=q.enter().append("g").attr("class","tick"),P=q.select("line"),j=q.select("text");S=S.merge(S.enter().insert("path",".tick").attr("class","domain").attr("stroke","#000")),q=q.merge(O),P=P.merge(O.append("line").attr("stroke","#000").attr(M+"2",v*d)),j=j.merge(O.append("text").attr("fill","#000").attr(M,v*f).attr("dy",t===p?"0em":t===x?"0.71em":"0.32em")),n!==H&&(S=S.transition(n),q=q.transition(n),P=P.transition(n),j=j.transition(n),w=w.transition(n).attr("opacity",k).attr("transform",function(t){return isFinite(t=V(t))?F(t):this.getAttribute("transform")}),O.attr("opacity",k).attr("transform",function(t){var n=this.parentNode.__axis;return F(n&&isFinite(n=n(t))?n:V(t))})),w.remove(),S.attr("d",t===g||t==h?"M"+v*y+","+z+"H0.5V"+A+"H"+v*y:"M"+z+","+v*y+"V0.5H"+A+"V"+v*y),q.attr("opacity",1).attr("transform",function(t){return F(V(t))}),P.attr(M+"2",v*d),j.attr(M,v*f).text(o),H.filter(a).attr("fill","none").attr("font-size",10).attr("font-family","sans-serif").attr("text-anchor",t===h?"start":t===g?"end":"middle"),H.each(function(){this.__axis=V})}var l=[],c=null,s=null,d=6,y=6,_=3,v=t===p||t===g?-1:1,M=t===g||t===h?"x":"y",F=t===p||t===x?n:r;return o.scale=function(t){return arguments.length?(u=t,o):u},o.ticks=function(){return l=f.slice.call(arguments),o},o.tickArguments=function(t){return arguments.length?(l=null==t?[]:f.slice.call(t),o):l.slice()},o.tickValues=function(t){return arguments.length?(c=null==t?null:f.slice.call(t),o):c&&c.slice()},o.tickFormat=function(t){return arguments.length?(s=t,o):s},o.tickSize=function(t){return arguments.length?(d=y=+t,o):d},o.tickSizeInner=function(t){return arguments.length?(d=+t,o):d},o.tickSizeOuter=function(t){return arguments.length?(y=+t,o):y},o.tickPadding=function(t){return arguments.length?(_=+t,o):_},o}function o(t){return u(p,t)}function l(t){return u(h,t)}function c(t){return u(x,t)}function s(t){return u(g,t)}Object.defineProperty(exports,"__esModule",{value:!0}),exports.axisTop=o,exports.axisRight=l,exports.axisBottom=c,exports.axisLeft=s;var f=require("./array"),d=require("./identity"),m=t(d),p=1,h=2,x=3,g=4,k=1e-6;
},{"./array":360,"./identity":363}],61:[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var e=require("./src/axis");Object.defineProperty(exports,"axisTop",{enumerable:!0,get:function(){return e.axisTop}}),Object.defineProperty(exports,"axisRight",{enumerable:!0,get:function(){return e.axisRight}}),Object.defineProperty(exports,"axisBottom",{enumerable:!0,get:function(){return e.axisBottom}}),Object.defineProperty(exports,"axisLeft",{enumerable:!0,get:function(){return e.axisLeft}});
},{"./src/axis":93}],95:[function(require,module,exports) {
"use strict";function n(){for(var n,e=0,t=arguments.length,o={};e<t;++e){if(!(n=arguments[e]+"")||n in o)throw new Error("illegal type: "+n);o[n]=[]}return new r(o)}function r(n){this._=n}function e(n,r){return n.trim().split(/^|\s+/).map(function(n){var e="",t=n.indexOf(".");if(t>=0&&(e=n.slice(t+1),n=n.slice(0,t)),n&&!r.hasOwnProperty(n))throw new Error("unknown type: "+n);return{type:n,name:e}})}function t(n,r){for(var e,t=0,o=n.length;t<o;++t)if((e=n[t]).name===r)return e.value}function o(n,r,e){for(var t=0,o=n.length;t<o;++t)if(n[t].name===r){n[t]=i,n=n.slice(0,t).concat(n.slice(t+1));break}return null!=e&&n.push({name:r,value:e}),n}Object.defineProperty(exports,"__esModule",{value:!0});var i={value:function(){}};r.prototype=n.prototype={constructor:r,on:function(n,r){var i,l=this._,a=e(n+"",l),f=-1,u=a.length;if(!(arguments.length<2)){if(null!=r&&"function"!=typeof r)throw new Error("invalid callback: "+r);for(;++f<u;)if(i=(n=a[f]).type)l[i]=o(l[i],n.name,r);else if(null==r)for(i in l)l[i]=o(l[i],n.name,null);return this}for(;++f<u;)if((i=(n=a[f]).type)&&(i=t(l[i],n.name)))return i},copy:function(){var n={},e=this._;for(var t in e)n[t]=e[t].slice();return new r(n)},call:function(n,r){if((e=arguments.length-2)>0)for(var e,t,o=new Array(e),i=0;i<e;++i)o[i]=arguments[i+2];if(!this._.hasOwnProperty(n))throw new Error("unknown type: "+n);for(i=0,e=(t=this._[n]).length;i<e;++i)t[i].value.apply(r,o)},apply:function(n,r,e){if(!this._.hasOwnProperty(n))throw new Error("unknown type: "+n);for(var t=this._[n],o=0,i=t.length;o<i;++o)t[o].value.apply(r,e)}},exports.default=n;
},{}],65:[function(require,module,exports) {
"use strict";function e(e){return e&&e.__esModule?e:{default:e}}Object.defineProperty(exports,"__esModule",{value:!0});var t=require("./src/dispatch");Object.defineProperty(exports,"dispatch",{enumerable:!0,get:function(){return e(t).default}});
},{"./src/dispatch":95}],314:[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var t=exports.xhtml="http://www.w3.org/1999/xhtml";exports.default={svg:"http://www.w3.org/2000/svg",xhtml:t,xlink:"http://www.w3.org/1999/xlink",xml:"http://www.w3.org/XML/1998/namespace",xmlns:"http://www.w3.org/2000/xmlns/"};
},{}],306:[function(require,module,exports) {
"use strict";function e(e){return e&&e.__esModule?e:{default:e}}Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=function(e){var r=e+="",s=r.indexOf(":");return s>=0&&"xmlns"!==(r=e.slice(0,s))&&(e=e.slice(s+1)),t.default.hasOwnProperty(r)?{space:t.default[r],local:e}:e};var r=require("./namespaces"),t=e(r);
},{"./namespaces":314}],303:[function(require,module,exports) {
"use strict";function e(e){return e&&e.__esModule?e:{default:e}}function t(e){return function(){var t
